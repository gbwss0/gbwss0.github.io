<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Gbwss" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="以TCP&#x2F;IP网络模型分层作为章节，并结合一些实际问题作为例子，包含常见的计算机网络相关问题，内容不断整理更新中">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络学习笔记">
<meta property="og:url" content="http://yoursite.com/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Gbwss">
<meta property="og:description" content="以TCP&#x2F;IP网络模型分层作为章节，并结合一些实际问题作为例子，包含常见的计算机网络相关问题，内容不断整理更新中">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s3.ax1x.com/2021/02/24/yXTUS0.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/09/ctXjDx.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/06/c1PgeK.png">
<meta property="og:image" content="https://s3.ax1x.com/2021/02/24/yXTPsO.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/08/cYLD6x.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/08/cYOKHO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ%E6%88%AA%E5%9B%BE20210317172225.png">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/09/cNCT1O.png">
<meta property="article:published_time" content="2021-03-23T08:16:55.000Z">
<meta property="article:modified_time" content="2022-10-15T02:06:33.801Z">
<meta property="article:author" content="Wang shushu">
<meta property="article:tag" content="计算机网络, 面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s3.ax1x.com/2021/02/24/yXTUS0.png">

<link rel="canonical" href="http://yoursite.com/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>计算机网络学习笔记 | Gbwss</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gbwss</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-23 16:16:55" itemprop="dateCreated datePublished" datetime="2021-03-23T16:16:55+08:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:06:33" itemprop="dateModified" datetime="2022-10-15T10:06:33+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>以TCP&#x2F;IP网络模型分层作为章节，并结合一些实际问题作为例子，包含常见的计算机网络相关问题，内容不断整理更新中</p>
<span id="more"></span>
<blockquote>
<p>OSI七层网络模型速记:物联(链)网淑(输)惠(会)试(示)用</p>
</blockquote>
<h1 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h1><p><img src="https://s3.ax1x.com/2021/02/24/yXTUS0.png" alt="img"><br>四层模型下: </p>
<ul>
<li>在四层，既传输层数据被称作<strong>段</strong>（Segments）；</li>
<li>三层网络层数据被称做<strong>包</strong>（Packages）；</li>
<li>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</li>
<li>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>传输单位：比特流<br>物理设备：中继器（信号再生），集线器（HDB）</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><p>传输单位：帧<br>典型协议：SDLC，HDLC，PPP，STP<br>功能：链路管理，！差错控制，！流量控制，传输管理，介质访问控制（MAC）<br>物理设备：网桥，交换机 &#x2F;&#x2F;工作在MAC子层，隔离碰撞域</p>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>传输单位：数据报<br>典型协议：IP，ICMP（网际控制报文协议），IGMP（因特网组管理协议，用于组播）ARP，RARP，OSPF，CIDR</p>
<blockquote>
<p>DHCP（应用层，UDP：68），RIP（应用层，UDP），OSPF（网络层，IP），BGP（应用层，TCP）<br>功能：流量控制，！拥塞控制，差错控制<br>注意：OSI模型在网络层支持无连接和面向连接的通信，但在传输层仅有面向连接的通信。而TCP&#x2F;IP模型认为可靠性是端到端的问题，因此在网络层只支持无连接的通信模式，而在传输层支持面向连接和无连接两种模式。<br>物理设别：路由器</p>
</blockquote>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输单位：报文段（TCP），用户数据报（UDP）<br>典型协议：TCP，UDP<br>功能：端到端传输，流量控制，差错控制，拥塞控制，服务质量</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP如何保证可靠性"><a href="#TCP如何保证可靠性" class="headerlink" title="TCP如何保证可靠性"></a>TCP如何保证可靠性</h3><ol>
<li>序列号、确认应答、超时重传</li>
</ol>
<p>数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</p>
<ol>
<li>窗口控制与快速重传（重复确认应答）</li>
</ol>
<p>TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。</p>
<p>使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒……</p>
<ol>
<li>拥塞控制（慢启动，拥塞避免，快重传，快恢复）<br><img src="https://z3.ax1x.com/2021/04/09/ctXjDx.png" alt="ctXjDx.png"></li>
</ol>
<p>如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。</p>
<p>慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。</p>
<p>拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答&#x2F;每个rtt，拥塞窗口大小+1），以此来避免拥塞。</p>
<p>将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。</p>
<p>快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。</p>
<p>然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。</p>
<p>这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。</p>
<h5 id="第一种回答"><a href="#第一种回答" class="headerlink" title="第一种回答"></a>第一种回答</h5><ul>
<li><strong>确认和重传</strong>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。</li>
<li><strong>数据校验</strong>：TCP报文头有校验和，用于校验报文是否损坏。</li>
<li><strong>数据合理分片和排序</strong>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。</li>
<li><strong>流量控制</strong>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。</li>
<li><strong>拥塞控制</strong>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。</li>
</ul>
<h5 id="第二种回答"><a href="#第二种回答" class="headerlink" title="第二种回答"></a>第二种回答</h5><ul>
<li>建立连接（标志位）：通信前确认通信实体存在。</li>
<li>序号机制（序号、确认号）：确保了数据是按序、完整到达。</li>
<li>数据校验（校验和）：CRC校验全部数据。</li>
<li>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</li>
<li>窗口机制（窗口）：提供流量控制，避免过量发送。</li>
<li>拥塞控制：同上。</li>
</ul>
<h5 id="第三种回答"><a href="#第三种回答" class="headerlink" title="第三种回答"></a>第三种回答</h5><p><strong>首部校验</strong><br>这个校验机制能够确保数据传输不会出错吗？ 答案是不能。</p>
<p><strong>原因</strong></p>
<p>TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。</p>
<p>这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？<strong>显然不能</strong>。</p>
<p>因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B&#x3D;B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。</p>
<p><strong>解决方案</strong></p>
<p>传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题</p>
<blockquote>
<p>《TCP新手误区–数据校验的意义》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/bjrxyz/article/details/75194716">https://blog.csdn.net/bjrxyz/article/details/75194716</a></p>
</blockquote>
<h3 id="流量控制原理"><a href="#流量控制原理" class="headerlink" title="流量控制原理"></a>流量控制原理</h3><ul>
<li>目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。</li>
<li>TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<ul>
<li>发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。</li>
<li>接收窗：用来标记可以接收的数据大小。</li>
</ul>
</li>
<li>TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 &#x3D; 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 &#x3D; 未接收但准备接收部分。</li>
<li>发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。</li>
</ul>
<h4 id="TCP-利用滑动窗口实现流量控制的机制"><a href="#TCP-利用滑动窗口实现流量控制的机制" class="headerlink" title="TCP 利用滑动窗口实现流量控制的机制"></a>TCP 利用滑动窗口实现流量控制的机制</h4><blockquote>
<p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p>
</blockquote>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着<strong>接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</p>
<blockquote>
<p>例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
</blockquote>
<h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><ul>
<li>拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。</li>
<li>TCP拥塞控制算法：<ul>
<li>慢开始 &amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。</li>
<li>快速重传 &amp; 快速恢复：略。</li>
<li>最终拥塞窗口会收敛于稳定值。</li>
</ul>
</li>
</ul>
<h3 id="如何区分流量控制和拥塞控制"><a href="#如何区分流量控制和拥塞控制" class="headerlink" title="如何区分流量控制和拥塞控制"></a>如何区分流量控制和拥塞控制</h3><ul>
<li>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</li>
<li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</li>
<li>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</li>
</ul>
<h3 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h3><p><img src="https://z3.ax1x.com/2021/04/06/c1PgeK.png" alt="img"></p>
<ul>
<li>端口号（16bit*2）：告知主机该报文段是来自哪里（源端口Source Port）以及传给哪个上层协议或应用程序（目的端口Destination Port）的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号（比如DNS协议对应端口53，HTTP协议对应80，这些端口号可在&#x2F;etc&#x2F;services文件中找到）。</li>
<li>序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 &#x3D; ISN + 数据在整个字节流中的偏移。假设A -&gt; B且ISN &#x3D; 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。</li>
<li>确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。</li>
<li>首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。</li>
<li>标志位（6bit）：<ul>
<li>URG：标志紧急指针是否有效。</li>
<li>ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。</li>
<li>PSH：提示接收端立即从缓冲读走数据。</li>
<li>RST：表示要求对方重新建立连接（复位报文段）。</li>
<li>SYN：表示请求建立一个连接（连接报文段）。</li>
<li>FIN：表示关闭连接（断开报文段）。</li>
</ul>
</li>
<li>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。</li>
<li>校验和（16bit）：接收端用CRC检验整个报文段有无损坏。</li>
<li>紧急指针（16bit）：（urgent pointer）是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li>
<li>TCP头部选项：TCP头部的最后一个选项字段（options）是可变长的可选信息。这部分最多包含40字节，因为TCP头部最长是60字节（其中还包含前面讨论的20字节的固定部分）。</li>
</ul>
<h3 id="TCP的三次握手四次挥手"><a href="#TCP的三次握手四次挥手" class="headerlink" title="TCP的三次握手四次挥手"></a>TCP的三次握手四次挥手</h3><p><img src="https://s3.ax1x.com/2021/02/24/yXTPsO.png" alt="yXTPsO.png"></p>
<h4 id="常见TCP的连接状态有哪些？"><a href="#常见TCP的连接状态有哪些？" class="headerlink" title="常见TCP的连接状态有哪些？"></a>常见TCP的连接状态有哪些？</h4><ul>
<li>CLOSED：初始状态。</li>
<li>LISTEN：服务器处于监听状态。</li>
<li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li>
<li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li>
</ul>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><p><img src="https://z3.ax1x.com/2021/04/08/cYLD6x.png" alt="cYLD6x.png"></p>
<ol>
<li>Client将标志位SYN置为1，随机产生一个值seq&#x3D;J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</li>
<li>Server收到数据包后由标志位SYN&#x3D;1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack&#x3D;J+1，随机产生一个值seq&#x3D;K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</li>
<li>Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack&#x3D;K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ol>
<h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><p>三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。</p>
<blockquote>
<p>例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。</p>
</blockquote>
<h4 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p><img src="https://z3.ax1x.com/2021/04/08/cYOKHO.png" alt="cYOKHO.png"></p>
<p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<ol>
<li>数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入<code>FIN_WAIT_1</code>状态，此时客户端依然可以接收服务器发送来的数据。</li>
<li>服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入<code>FIN_WAIT_2</code>状态。&#x2F;&#x2F;这时候是一个半关闭状态，服务器仍可以向客户端发送数据。</li>
<li>当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入<code>LAST_ACK</code>状态，等待客户端的确认</li>
<li>客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入<code>TIME_WAIT</code>状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。</li>
</ol>
<h4 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h4><p>由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read&#x3D;&#x3D;0来判断对端是否关闭连接。</p>
<h4 id="四次挥手释放连接时，等待2MSL的意义"><a href="#四次挥手释放连接时，等待2MSL的意义" class="headerlink" title="四次挥手释放连接时，等待2MSL的意义"></a>四次挥手释放连接时，等待2MSL的意义</h4><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p>
<p>两个理由</p>
<ol>
<li>保证客户端发送的最后一个ACK报文段能够到达服务端。 这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。</li>
<li>防止“已失效的连接请求报文段”出现在本连接中。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<blockquote>
<p>MSL（Maximum Segment Lifetime）最大报文生存时间: 每个TCP实现必须选择一个MSL。它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL时间。RFC 793指出MSL为2分钟，现实中常用30秒或1分钟。</p>
</blockquote>
<blockquote>
<p>TTL（time-to-live）生存时间字段: 在IP首部中的8位字段。该字段不是存的具体时间，而是设置了数据报可以经过的最多路由器数。它制定了数据报的生存时间。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，它的值就减去1.当该字段值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。</p>
</blockquote>
<blockquote>
<p>RTT（round-trip-time）往返时间: TCP超时与重传中最重要的部分就是对一个给定连接的往返时间RTT的测量。由于路由器和网络流量均会变化，因此这个时间可能经常会变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
</blockquote>
<blockquote>
<p>MTU：(maximum transmission unit)最大传输单元:由硬件规定，如以太网的MTU为1500字节。</p>
</blockquote>
<blockquote>
<p>MSS：(maximum segment size)最大分节大小:为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</p>
</blockquote>
<h3 id="TCP粘包问题是什么？你会如何去解决它？"><a href="#TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="TCP粘包问题是什么？你会如何去解决它？"></a>TCP粘包问题是什么？你会如何去解决它？</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<ul>
<li>由TCP连接复用造成的粘包问题。</li>
<li>因为TCP默认会使用Nagle算法，此算法会导致粘包问题。</li>
<li>只有上一个分组得到确认，才会发送下一个分组；</li>
<li>收集多个小分组，在一个确认到来时一起发送。</li>
<li>数据包过大造成的粘包问题。</li>
<li>流量控制，拥塞控制也可能导致粘包。</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
<p><strong>解决</strong>：</p>
<ul>
<li>Nagle算法问题导致的，需要结合应用场景适当关闭该算法</li>
<li><strong>尾部标记序列</strong>.通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。</li>
<li><strong>头部标记分步接收</strong>.在TCP报文的头部加上表示数据长度。</li>
<li>应用层发送数据时定长发送。</li>
</ul>
<h3 id="DDos-攻击了解吗？"><a href="#DDos-攻击了解吗？" class="headerlink" title="DDos 攻击了解吗？"></a>DDos 攻击了解吗？</h3><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认<br>没有彻底根治的办法，除非不使用TCP<br>DDos 预防：<br>1）限制同时打开SYN半链接的数目<br>2）缩短SYN半链接的Time out 时间<br>3）关闭不必要的服务</p>
<hr>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p>
<p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p>
<p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p>
<p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p>
<p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p>
<p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</p>
<p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>
<p>7、UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p>
<p>TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p>
<blockquote>
<p>《TCP数据段格式+UDP数据段格式详解》：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/love-jelly-pig/p/8471181.html">https://www.cnblogs.com/love-jelly-pig/p/8471181.html</a></p>
</blockquote>
<h4 id="UDP的特点有哪些（附赠TCP的特点）"><a href="#UDP的特点有哪些（附赠TCP的特点）" class="headerlink" title="UDP的特点有哪些（附赠TCP的特点）"></a>UDP的特点有哪些（附赠TCP的特点）</h4><ul>
<li>UDP是<strong>无连接的</strong>；</li>
<li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</li>
<li>UDP是<strong>面向报文</strong>的；</li>
<li>UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；</li>
<li>UDP<strong>支持一对一、一对多、多对一和多对多</strong>的交互通信；</li>
<li>UDP的<strong>首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li>
</ul>
<p>那么，再说一次TCP的特点：</p>
<ul>
<li><strong>TCP是面向连接的</strong>。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</li>
<li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（<strong>一对一</strong>）；</li>
<li>TCP<strong>提供可靠交付的服务</strong>。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；</li>
<li>TCP<strong>提供全双工通信</strong>。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li>
<li><strong>面向字节流</strong>。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</li>
</ul>
<h3 id="TCP对应的应用层协议"><a href="#TCP对应的应用层协议" class="headerlink" title="TCP对应的应用层协议"></a>TCP对应的应用层协议</h3><p>FTP：定义了文件传输协议，使用21端口.<br>Telnet：它是一种用于远程登陆的端口,23端口<br>SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。<br>POP3：它是和SMTP对应，POP3用于接收邮件。</p>
<h3 id="UDP对应的应用层协议"><a href="#UDP对应的应用层协议" class="headerlink" title="UDP对应的应用层协议"></a>UDP对应的应用层协议</h3><p>DNS：用于域名解析服务，用的是53号端口<br>SNMP：简单网络管理协议，使用161号端口<br>TFTP(Trival File Transfer Protocal)：简单文件传输协议，69</p>
<h3 id="在进行UDP编程的时候，一次发送多少bytes好"><a href="#在进行UDP编程的时候，一次发送多少bytes好" class="headerlink" title="在进行UDP编程的时候，一次发送多少bytes好"></a>在进行UDP编程的时候，一次发送多少bytes好</h3><p>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。</p>
<p>我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP&#x2F;IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,</p>
<p>下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.</p>
<p>所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。</p>
<p>当我们发送的UDP数据大于1472的时候会怎样呢？<br>这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).<br>把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.<br>这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便<br>无法重组数据报.将导致丢弃整个UDP数据报。</p>
<p>因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.</p>
<p>进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.<br>如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机<br>制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.</p>
<p>鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.<br>最好将UDP的数据长度控件在548字节(576-8-20)以内</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>典型协议：DNS（UDP，53），SMTP（TCP，25）：IMAP（TCP，143，有状态）&#x2F;POP3（TCP，110，无状态），FTP（TCP，21(控制)，20(传输)）</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS是什么"><a href="#DNS是什么" class="headerlink" title="DNS是什么"></a>DNS是什么</h3><p><strong>官方解释</strong>：DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，比如<a href="http://www.baidu.xn--com%2Cip%2C:167-n50um0mez3b1har58al0jdv9ch1yavd6ck25brn6c.23.10.2./">www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。</a></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）</p>
<p><img src="https://cdn.jsdelivr.net/gh/forthespada/mediaImage1@1.6.4.1/202103/QQ%E6%88%AA%E5%9B%BE20210317172225.png" alt="img"><br>过程：<br>总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。<br>一、主机向本地域名服务器的查询一般都是采用递归查询。<br>二、本地域名服务器向根域名服务器的查询的迭代查询。<br>1)当用户输入域名时，浏览器先检查自己的缓存中是否有这个域名映射的ip地址，有解析结束。<br>2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。<br>3）若无命中，则请求本地域名服务器解析（LDNS）。<br>4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个主域名服务器地址。<br>5） 此时LDNS再发送请求给上一步返回的gTLD（通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址<br>6） Name Server根据映射关系表找到目标ip，返回给LDNS<br>7） LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ol>
<li>HTTP协议：<br>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。</li>
</ol>
<p>HTTP是一个基于TCP&#x2F;IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。</p>
<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP&#x2F;1.0的第六版，HTTP&#x2F;1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。</p>
<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<ol>
<li>HTTP协议特点</li>
</ol>
<p>1、简单快速：</p>
<p>客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>
<p>2、灵活：</p>
<p>HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>
<p>3、无连接：</p>
<p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<p>4、无状态：</p>
<p>HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<p>5、支持B&#x2F;S及C&#x2F;S模式。</p>
<p>6、默认端口80</p>
<p>7、基于TCP协议</p>
<ol>
<li>HTTP过程概述：</li>
</ol>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>HTTP 请求&#x2F;响应的步骤如下：</p>
<p>域名解析 –&gt; 发起TCP的3次握手 –&gt; 建立TCP连接后发起http请求 –&gt; 服务器响应http请求，浏览器得到html代码 –&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） –&gt; 浏览器对页面进行渲染呈现给用户。</p>
<p>1、客户端连接到Web服务器</p>
<p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a target="_blank" rel="noopener" href="http://www.baidu.com./">http://www.baidu.com。</a></p>
<p>2、发送HTTP请求</p>
<p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p>
<p>3、服务器接受请求并返回HTTP响应</p>
<p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p>
<p>4、释放连接TCP连接</p>
<p>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p>
<p>5、客户端浏览器解析HTML内容</p>
<p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>
<ol>
<li>举例：</li>
</ol>
<p>在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；</p>
<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；</p>
<p>3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</p>
<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；</p>
<p>5、释放 TCP连接；</p>
<p>6、浏览器将该 html 文本并显示内容；</p>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>客户端发送的 <strong>请求报文</strong> 第一行为请求行，包含了方法字段。</p>
<p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<table>
<thead>
<tr>
<th align="left">序 号</th>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">HEAD</td>
<td align="left">类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">PUT</td>
<td align="left">从客户端向服务器传送的数据取代指定的文档的内容。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的页面。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">CONNECT</td>
<td align="left">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">PATCH</td>
<td align="left">是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>
</tr>
</tbody></table>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol>
<li>HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性</li>
<li>HTTPS在TCP三次握手阶段之后，还需要进行SSL的handshake，协商加密使用的对称加密密钥</li>
<li>HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书</li>
<li>HTTP协议端口是80，HTTPS协议端口是443</li>
</ol>
<h3 id="对称-x2F-非对称加密算法在HTTPS协议中的应用"><a href="#对称-x2F-非对称加密算法在HTTPS协议中的应用" class="headerlink" title="对称&#x2F;非对称加密算法在HTTPS协议中的应用"></a>对称&#x2F;非对称加密算法在HTTPS协议中的应用</h3><ol>
<li><strong>客户端发起HTTPS请求</strong><br>这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。</li>
<li><strong>服务端的配置</strong><br>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li>
<li><strong>传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li>
<li><strong>客户端解析证书</strong><br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li>
</ol>
<p>5.<strong>传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>
<p>6.<strong>服务段解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
<p>7.<strong>传输加密后的信息</strong><br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原</p>
<p>8.<strong>客户端解密信息</strong><br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p>
<p>非对称加密算法的性能是非常低的，原因在于寻找大素数、大数计算、数据分割需要耗费很多的CPU周期，所以<strong>一般的HTTPS连接只在第一次握手时使用非对称加密，通过握手交换对称加密密钥，在之后的通信走对称加密</strong>。</p>
<h3 id="GET-方法参数写法是固定的吗？"><a href="#GET-方法参数写法是固定的吗？" class="headerlink" title="GET 方法参数写法是固定的吗？"></a>GET 方法参数写法是固定的吗？</h3><p>在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。</p>
<p>我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。</p>
<p>比如header请求头中添加token，来验证用户是否登录等权限问题。</p>
<p>也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。</p>
<h3 id="GET-方法的长度限制是怎么回事？"><a href="#GET-方法的长度限制是怎么回事？" class="headerlink" title="GET 方法的长度限制是怎么回事？"></a>GET 方法的长度限制是怎么回事？</h3><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p>
<p>首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p>
<p>浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p>
<h3 id="POST-方法比-GET-方法安全？"><a href="#POST-方法比-GET-方法安全？" class="headerlink" title="POST 方法比 GET 方法安全？"></a>POST 方法比 GET 方法安全？</h3><p>有人说POST 比 GET 安全，因为数据在地址栏上不可见。</p>
<p>然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。</p>
<p>要想安全传输，就只有加密，也就是 HTTPS。</p>
<h3 id="POST-方法会产生两个-TCP-数据包？你了解吗？"><a href="#POST-方法会产生两个-TCP-数据包？你了解吗？" class="headerlink" title="POST 方法会产生两个 TCP 数据包？你了解吗？"></a>POST 方法会产生两个 TCP 数据包？你了解吗？</h3><p>有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。</p>
<p>HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。</p>
<p>所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</p>
<h3 id="GET与POST传递数据的最大长度能够达到多少呢"><a href="#GET与POST传递数据的最大长度能够达到多少呢" class="headerlink" title="GET与POST传递数据的最大长度能够达到多少呢"></a>GET与POST传递数据的最大长度能够达到多少呢</h3><p>get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。</p>
<p>很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。</p>
<p>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。</p>
<p>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。</p>
<p>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。</p>
<h3 id="Cookie与Session的对比"><a href="#Cookie与Session的对比" class="headerlink" title="Cookie与Session的对比"></a>Cookie与Session的对比</h3><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是客户端保持状态的方法。</p>
<p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p>
<p>除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session是服务器保持状态的方法。</p>
<p>首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p>
<p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p>
<h3 id="HTTPS的优缺点"><a href="#HTTPS的优缺点" class="headerlink" title="HTTPS的优缺点"></a>HTTPS的优缺点</h3><h4 id="HTTPS优点："><a href="#HTTPS优点：" class="headerlink" title="HTTPS优点："></a>HTTPS优点：</h4><p>HTTPS传输数据过程中使用密钥进行加密，所以安全性更高</p>
<p>HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器</p>
<p>非对称加密</p>
<h4 id="HTTPS缺点："><a href="#HTTPS缺点：" class="headerlink" title="HTTPS缺点："></a>HTTPS缺点：</h4><p>HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加</p>
<p>HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p>
<p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
<p>区别：</p>
<ol>
<li>get参数通过url传递，post放在request body中。</li>
<li>get请求在url中传递的参数是有长度限制的，而post没有。</li>
<li>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</li>
<li>get请求只能进行url编码，而post支持多种编码方式。</li>
<li>get请求会浏览器主动cache，而post支持多种编码方式。</li>
<li>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</li>
<li>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。</li>
<li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li>
</ol>
<h3 id="HTTP返回码"><a href="#HTTP返回码" class="headerlink" title="HTTP返回码"></a>HTTP返回码</h3><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">类别</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational（信息性状态码）</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success（成功状态码）</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection（重定向状态码）</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error（客户端错误状态码）</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error（服务器错误状态码）</td>
<td align="left">服务器处理请求出</td>
</tr>
</tbody></table>
<h4 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx 信息"></a>1xx 信息</h4><p><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h4><ul>
<li><strong>200 OK</strong></li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h4><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>305 Use Proxy</strong> ：这个响应代码用于告诉客户端它需要再发一次请求，但这次要通过一个HTTP代理发送，而不是直接发送给服务器。这个响应代码使用的不多，因为服务器很少在意客户端是否使用某一特定代理。这个代码主要用于基于代理的镜像站点。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h4 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a>4xx 客户端错误</h4><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong></li>
</ul>
<h4 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx 服务器错误"></a>5xx 服务器错误</h4><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h2 id="安全相关问题"><a href="#安全相关问题" class="headerlink" title="安全相关问题"></a>安全相关问题</h2><h4 id="XSS攻击是什么？"><a href="#XSS攻击是什么？" class="headerlink" title="XSS攻击是什么？"></a>XSS攻击是什么？</h4><p>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击<br>1）前端，服务端，同时需要字符串输入的长度限制。<br>2）前端，服务端，同时需要对HTML转义处理。将其中的”&lt;”,”&gt;”等特殊字符进行转义编码。<br>防 XSS 的核心是必须对输入的数据做过滤处理。</p>
<h4 id="CSRF攻击？你知道吗？"><a href="#CSRF攻击？你知道吗？" class="headerlink" title="CSRF攻击？你知道吗？"></a>CSRF攻击？你知道吗？</h4><p>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。</p>
<h4 id="如何防范CSRF攻击"><a href="#如何防范CSRF攻击" class="headerlink" title="如何防范CSRF攻击"></a>如何防范CSRF攻击</h4><p><strong>安全框架</strong>，例如Spring Security。<br><strong>token机制</strong>。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。<br><strong>验证码</strong>。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。<br><strong>referer识别</strong>。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。<br>1）验证请求来源地址；<br>2）关键操作添加验证码；<br>3）在请求地址添加 token 并验证。</p>
<h4 id="文件上传漏洞是如何发生的？你有经历过吗？"><a href="#文件上传漏洞是如何发生的？你有经历过吗？" class="headerlink" title="文件上传漏洞是如何发生的？你有经历过吗？"></a>文件上传漏洞是如何发生的？你有经历过吗？</h4><p>文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。<br>许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。</p>
<h4 id="如何防范文件上传漏洞"><a href="#如何防范文件上传漏洞" class="headerlink" title="如何防范文件上传漏洞"></a>如何防范文件上传漏洞</h4><p>文件上传的目录设置为不可执行。<br>1）判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。<br>2）对上传的文件类型进行白名单校验，只允许上传可靠类型。<br>3）上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。<br>4）限制上传文件的大小。<br>5）单独设置文件服务器的域名。</p>
<h4 id="DDos-攻击了解吗？-1"><a href="#DDos-攻击了解吗？-1" class="headerlink" title="DDos 攻击了解吗？"></a>DDos 攻击了解吗？</h4><p>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认<br>没有彻底根治的办法，除非不使用TCP<br>DDos 预防：<br>1）限制同时打开SYN半链接的数目<br>2）缩短SYN半链接的Time out 时间<br>3）关闭不必要的服务</p>
<h4 id="SYN攻击-1"><a href="#SYN攻击-1" class="headerlink" title="SYN攻击"></a>SYN攻击</h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS&#x2F;DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p><img src="https://z3.ax1x.com/2021/04/09/cNCT1O.png" alt="cNCT1O.png"></p>
<h1 id="总体问题"><a href="#总体问题" class="headerlink" title="总体问题"></a>总体问题</h1><h2 id="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h2><p>浏览器中输入URL<br>浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</p>
<p>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</p>
<p>其中：</p>
<ol>
<li>DNS协议，http协议，https协议属于应用层</li>
</ol>
<p>应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。</p>
<ol>
<li>TCP&#x2F;UDP属于传输层</li>
</ol>
<p>传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。</p>
<ol>
<li>IP协议，ARP协议属于网络层</li>
</ol>
<p>网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP&#x2F;IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。</p>
<ol>
<li>数据链路层</li>
</ol>
<p>当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。</p>
<ol>
<li>物理层</li>
</ol>
<p>物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。</p>
<h2 id="会话层表示层"><a href="#会话层表示层" class="headerlink" title="会话层表示层"></a>会话层表示层</h2><ul>
<li>表示层：图像、视频编码解，数据加密。</li>
<li>会话层：建立会话，如session认证、断点续传。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E9%9D%A2%E8%AF%95/" rel="tag"># 计算机网络, 面试</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="操作系统学习笔记">
                  <i class="fa fa-chevron-left"></i> 操作系统学习笔记
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2021/10/27/iOS-URLSession/" rel="prev" title="iOS-URLSession">
                  iOS-URLSession <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-x2F-IP%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">TCP&#x2F;IP模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-number">2.</span> <span class="nav-text">物理层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-number">3.</span> <span class="nav-text">链路层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">4.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">5.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">5.1.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">5.1.1.</span> <span class="nav-text">TCP如何保证可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%9B%9E%E7%AD%94"><span class="nav-number">5.1.1.0.1.</span> <span class="nav-text">第一种回答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%9B%9E%E7%AD%94"><span class="nav-number">5.1.1.0.2.</span> <span class="nav-text">第二种回答</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%9B%9E%E7%AD%94"><span class="nav-number">5.1.1.0.3.</span> <span class="nav-text">第三种回答</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.2.</span> <span class="nav-text">流量控制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E5%88%A9%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">TCP 利用滑动窗口实现流量控制的机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.3.</span> <span class="nav-text">拥塞控制原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.1.4.</span> <span class="nav-text">如何区分流量控制和拥塞控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A4%B4%E9%83%A8"><span class="nav-number">5.1.5.</span> <span class="nav-text">TCP头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.1.6.</span> <span class="nav-text">TCP的三次握手四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">常见TCP的连接状态有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9A"><span class="nav-number">5.1.6.2.</span> <span class="nav-text">三次握手：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.1.6.3.</span> <span class="nav-text">三次握手的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN%E6%94%BB%E5%87%BB"><span class="nav-number">5.1.6.4.</span> <span class="nav-text">SYN攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9A"><span class="nav-number">5.1.6.5.</span> <span class="nav-text">四次挥手：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">5.1.6.6.</span> <span class="nav-text">四次挥手的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E7%AD%89%E5%BE%852MSL%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">5.1.6.7.</span> <span class="nav-text">四次挥手释放连接时，等待2MSL的意义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E5%8E%BB%E8%A7%A3%E5%86%B3%E5%AE%83%EF%BC%9F"><span class="nav-number">5.1.7.</span> <span class="nav-text">TCP粘包问题是什么？你会如何去解决它？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DDos-%E6%94%BB%E5%87%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">5.1.8.</span> <span class="nav-text">DDos 攻击了解吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-number">5.2.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.1.</span> <span class="nav-text">TCP和UDP的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDP%E7%9A%84%E7%89%B9%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E9%99%84%E8%B5%A0TCP%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%89"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">UDP的特点有哪些（附赠TCP的特点）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.2.2.</span> <span class="nav-text">TCP对应的应用层协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.2.3.</span> <span class="nav-text">UDP对应的应用层协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%BF%9B%E8%A1%8CUDP%E7%BC%96%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%B8%80%E6%AC%A1%E5%8F%91%E9%80%81%E5%A4%9A%E5%B0%91bytes%E5%A5%BD"><span class="nav-number">5.2.4.</span> <span class="nav-text">在进行UDP编程的时候，一次发送多少bytes好</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">6.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">6.1.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">6.1.1.</span> <span class="nav-text">DNS是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">6.1.2.</span> <span class="nav-text">工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">6.2.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.1.</span> <span class="nav-text">HTTP请求方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.2.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0-x2F-%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%9C%A8HTTPS%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">6.2.3.</span> <span class="nav-text">对称&#x2F;非对称加密算法在HTTPS协议中的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E5%86%99%E6%B3%95%E6%98%AF%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">6.2.4.</span> <span class="nav-text">GET 方法参数写法是固定的吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET-%E6%96%B9%E6%B3%95%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="nav-number">6.2.5.</span> <span class="nav-text">GET 方法的长度限制是怎么回事？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST-%E6%96%B9%E6%B3%95%E6%AF%94-GET-%E6%96%B9%E6%B3%95%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">6.2.6.</span> <span class="nav-text">POST 方法比 GET 方法安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POST-%E6%96%B9%E6%B3%95%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%A4%E4%B8%AA-TCP-%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9F%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.2.7.</span> <span class="nav-text">POST 方法会产生两个 TCP 数据包？你了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E4%B8%8EPOST%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E8%83%BD%E5%A4%9F%E8%BE%BE%E5%88%B0%E5%A4%9A%E5%B0%91%E5%91%A2"><span class="nav-number">6.2.8.</span> <span class="nav-text">GET与POST传递数据的最大长度能够达到多少呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie%E4%B8%8ESession%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">6.2.9.</span> <span class="nav-text">Cookie与Session的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie"><span class="nav-number">6.2.9.1.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session"><span class="nav-number">6.2.9.2.</span> <span class="nav-text">Session</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">6.2.10.</span> <span class="nav-text">HTTPS的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="nav-number">6.2.10.1.</span> <span class="nav-text">HTTPS优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="nav-number">6.2.10.2.</span> <span class="nav-text">HTTPS缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.11.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E8%BF%94%E5%9B%9E%E7%A0%81"><span class="nav-number">6.2.12.</span> <span class="nav-text">HTTP返回码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1xx-%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.12.1.</span> <span class="nav-text">1xx 信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2xx-%E6%88%90%E5%8A%9F"><span class="nav-number">6.2.12.2.</span> <span class="nav-text">2xx 成功</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3xx-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">6.2.12.3.</span> <span class="nav-text">3xx 重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-number">6.2.12.4.</span> <span class="nav-text">4xx 客户端错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-number">6.2.12.5.</span> <span class="nav-text">5xx 服务器错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.</span> <span class="nav-text">安全相关问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XSS%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.3.0.1.</span> <span class="nav-text">XSS攻击是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF%E6%94%BB%E5%87%BB%EF%BC%9F%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="nav-number">6.3.0.2.</span> <span class="nav-text">CSRF攻击？你知道吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83CSRF%E6%94%BB%E5%87%BB"><span class="nav-number">6.3.0.3.</span> <span class="nav-text">如何防范CSRF攻击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%94%9F%E7%9A%84%EF%BC%9F%E4%BD%A0%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E5%90%97%EF%BC%9F"><span class="nav-number">6.3.0.4.</span> <span class="nav-text">文件上传漏洞是如何发生的？你有经历过吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E"><span class="nav-number">6.3.0.5.</span> <span class="nav-text">如何防范文件上传漏洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DDos-%E6%94%BB%E5%87%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F-1"><span class="nav-number">6.3.0.6.</span> <span class="nav-text">DDos 攻击了解吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYN%E6%94%BB%E5%87%BB-1"><span class="nav-number">6.3.0.7.</span> <span class="nav-text">SYN攻击</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DHCP"><span class="nav-number">6.4.</span> <span class="nav-text">DHCP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">总体问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2baidu%EF%BC%8C%E4%BC%9A%E7%94%A8%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%BB%80%E4%B9%88%E5%B1%82%EF%BC%9F%E6%AF%8F%E5%B1%82%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84"><span class="nav-number">7.1.</span> <span class="nav-text">搜索baidu，会用到计算机网络中的什么层？每层是干什么的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="nav-number">7.2.</span> <span class="nav-text">会话层表示层</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang shushu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang shushu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

</body>
</html>
