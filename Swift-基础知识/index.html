<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="-– title: Swift-基础知识 date: 2021-10-18 09:41:00 tags:  -–">
<meta property="og:type" content="article">
<meta property="og:title" content="瞎写写">
<meta property="og:url" content="http://yoursite.com/Swift-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="瞎写写">
<meta property="og:description" content="-– title: Swift-基础知识 date: 2021-10-18 09:41:00 tags:  -–">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://box.kancloud.cn/2015-08-11_55c98e2314bad.png">
<meta property="og:image" content="https://box.kancloud.cn/2015-08-11_55c9902b7e35e.png">
<meta property="og:image" content="https://i.loli.net/2021/08/26/FvOknEqfCbxGoJw.png">
<meta property="og:image" content="https://i.loli.net/2021/08/26/ewfr4ICdycFlMJW.jpg">
<meta property="og:image" content="https://i.loli.net/2021/08/26/4wYxHob7AdZKaNi.png">
<meta property="og:image" content="https://i.loli.net/2021/08/26/1lJIPOnfyTMRFvu.png">
<meta property="article:published_time" content="2022-09-02T02:47:53.000Z">
<meta property="article:modified_time" content="2022-09-02T02:47:53.000Z">
<meta property="article:author" content="王帅帅">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://box.kancloud.cn/2015-08-11_55c98e2314bad.png">

<link rel="canonical" href="http://yoursite.com/Swift-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title> | 瞎写写</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">瞎写写</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Swift-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王帅帅">
      <meta itemprop="description" content="写点有意思的东西">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞎写写">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-02 10:47:53" itemprop="dateCreated datePublished" datetime="2022-09-02T10:47:53+08:00">2022-09-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>-–</p>
<p>title: Swift-基础知识</p>
<p>date: 2021-10-18 09:41:00</p>
<p>tags: </p>
<p>-–</p>
<p><escape><span id="more"></span></escape></p>
<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h3 id="数值型类型转换-Numeric-Type-Conversion"><a href="#数值型类型转换-Numeric-Type-Conversion" class="headerlink" title="数值型类型转换(Numeric Type Conversion)"></a>数值型类型转换(Numeric Type Conversion)</h3><p>和c语言的强制类型转换类似，利用括号进行数值型类型转换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> two: <span class="type">UInt16</span> <span class="operator">=</span> <span class="number">2000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> twopone <span class="operator">=</span> two <span class="operator">+</span> <span class="type">UInt16</span>(one)</span><br><span class="line"><span class="comment">//如果这里不对 one 进行强制类型转换的话，就会报错</span></span><br><span class="line"><span class="comment">//Binary operator &#x27;+&#x27; cannot be applied to operands of type &#x27;UInt16&#x27; and &#x27;UInt8&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(twopone)</span><br><span class="line"><span class="comment">//2010</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意:<br>SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。在语言内部， UInt16 有一个构造器，可以接受一个 UInt8 类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16 。<br>所以说他不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。<strong>不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）</strong></p>
</blockquote>
<p>当用这种方式来初始化一个新的整数值时，浮点值会被截断。也就是说 4.75 会变成 4 ， -3.9 会变成 -3 ，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> three <span class="operator">=</span> <span class="number">1.99</span></span><br><span class="line"><span class="keyword">let</span> four <span class="operator">=</span> <span class="type">Int</span>(three)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(four)</span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br>结合数字类常量和变量不同于结合数字类字面量。字面量 3 可以直接和字面量 0.14159 相加，因为<strong>数字字面量本身没有明确的类型</strong>。它们的类型只在编译器需要求值的时候被推测。</p>
</blockquote>
<h3 id="类型别名-type-aliases"><a href="#类型别名-type-aliases" class="headerlink" title="类型别名(type aliases)"></a>类型别名(type aliases)</h3><p>使用 typealias 关键字来定义类型别名</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Sample</span> <span class="operator">=</span> <span class="type">UInt16</span></span><br><span class="line"><span class="keyword">let</span> five <span class="operator">=</span> <span class="type">Sample</span>.min</span><br><span class="line"><span class="built_in">print</span>(five)</span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h3><p>如果你在需要使用 Bool 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// 这个例子不会通过编译，会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子会编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元组-tuples"><a href="#元组-tuples" class="headerlink" title="元组(tuples)"></a>元组(tuples)</h3><p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。<br>分解的时候可以把要忽略的部分用下划线（  _ ）标记，还可以通过下标来访问元组中的单个元素：</p>
<p>可以在定义元组的时候给单个元素<strong>命名</strong>，然后通过名字来获取元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> http300Status <span class="operator">=</span> (statusCode: <span class="number">300</span>, description: <span class="string">&quot;OK&quot;</span>, <span class="number">300</span>, <span class="number">400</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;niuniu: <span class="subst">\(http200Status.statusCode)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//niuniu: 200</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;niuwa: <span class="subst">\(http300Status.<span class="number">2</span>)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//niuwa: 300</span></span><br><span class="line"><span class="keyword">let</span> (<span class="keyword">_</span>, h4, <span class="keyword">_</span>, <span class="keyword">_</span>) <span class="operator">=</span> http300Status</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;zhenniu: <span class="subst">\(h4)</span>&quot;</span>)</span><br><span class="line"><span class="comment">//zhenniu: OK</span></span><br></pre></td></tr></table></figure>

<h3 id="可选类型-optionals"><a href="#可选类型-optionals" class="headerlink" title="可选类型(optionals)"></a>可选类型(optionals)</h3><p>下面的例子使用 toInt 方法来尝试将一个 String 转换成 Int ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleNumber <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> convertedNumber <span class="operator">=</span> possibleNumber.toInt()</span><br><span class="line"><span class="comment">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</span></span><br></pre></td></tr></table></figure>

<p>因为 toInt 方法可能会失败，所以它返回一个_可选类型（optional） Int ，而不是一个 Int 。一个可选的 Int 被写作 Int? 而不是 Int 。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值比如 Bool 值或者 String 值。只能是 Int 或者什么都没有。）</p>
<h3 id="强制解析-forced-unwrapping"><a href="#强制解析-forced-unwrapping" class="headerlink" title="强制解析(forced unwrapping)"></a>强制解析(forced unwrapping)</h3><p>当确定可选类型包含值的时候，就可以加个感叹号来获取值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> convertedNumber <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;convertedNumber has an integer value of <span class="subst">\(convertedNumber<span class="operator">!</span>)</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选绑定-optional-binding"><a href="#可选绑定-optional-binding" class="headerlink" title="可选绑定(optional binding)"></a>可选绑定(optional binding)</h3><p>可选绑定可以用在 if 和 while 语句中来对可选类型的值进行判断并把值赋给一个常量或者变量，然后在内部可以使用这个值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果这里不加?声明 optionalString 是一个可选值的话，第二行就会报错，提示变量没有初始化</span></span><br><span class="line"><span class="comment">//Variable &#x27;optionalString&#x27; used before being initialized</span></span><br><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>?</span><br><span class="line"><span class="built_in">print</span>(optionalString <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    greeting <span class="operator">=</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个可选绑定可以用逗号区分成一列表达式出现在一个<code>if</code>语句中。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> constantName <span class="operator">=</span> someOptional, anotherConstantName <span class="operator">=</span> someOtherOptional &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我觉得这个很有用，利用if避免了错误的发生，又实现了类型强制解析的目的，当然用 空合运算符 也很好</p>
</blockquote>
<h3 id="隐式解析可选类型-implicitly-unwrapped-optionals"><a href="#隐式解析可选类型-implicitly-unwrapped-optionals" class="headerlink" title="隐式解析可选类型(implicitly unwrapped optionals)"></a>隐式解析可选类型(implicitly unwrapped optionals)</h3><p>把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;An optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> <span class="operator">=</span> possibleString<span class="operator">!</span> <span class="comment">// 需要惊叹号来获取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String</span>! <span class="operator">=</span> <span class="string">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> <span class="operator">=</span> assumedString  <span class="comment">// 不需要感叹号</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的理解就是加了感叹号就直接认为他是有值的，需要的时候就把它传递出去，不管他是不是空的。这个就和强制解析一样的东西。如果没有值的话就会直接出错。</p>
</blockquote>
<h2 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h2><h3 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h3><p>空合运算符( a ?? b )将对可选类型 a 进行空判断，如果 a 包含一个值就进行解封，否则就返回一个默认值 b .这个运算符有两个条件:</p>
<ul>
<li>表达式 a 必须是Optional类型</li>
<li>默认值 b 的类型必须要和 a 存储值的类型保持一致</li>
</ul>
<p>空合并运算符是对以下代码的简短表达方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">?</span> a<span class="operator">!</span> : b</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br> 如果 a 为非空值( non-nil ),那么值 b 将不会被估值。这也就是所谓的短路求值。<br>但是我测试如果b也为可选类型，那么会直接出现一个nil</p>
</blockquote>
<h3 id="区间运算符"><a href="#区间运算符" class="headerlink" title="区间运算符"></a>区间运算符</h3><ul>
<li>闭区间运算符（ a…b ）定义一个包含从 a 到 b (包括 a 和 b )的所有值的区间， b 必须大于等于 a </li>
<li>半开区间（ a..&lt; b ）定义一个从 a 到 b 但不包括 b 的区间</li>
</ul>
<h2 id="字符串和字符"><a href="#字符串和字符" class="headerlink" title="字符串和字符"></a>字符串和字符</h2><h3 id="字符串字面量（String-Literals）"><a href="#字符串字面量（String-Literals）" class="headerlink" title="字符串字面量（String Literals）"></a>字符串字面量（String Literals）</h3><p>字符串字面量是由双引号 (“”) 包裹着的具有固定顺序的文本字符集。 字符串字面量可以用于为常量和变量提供初始值。</p>
<h3 id="字符串是值类型（Strings-Are-Value-Types）"><a href="#字符串是值类型（Strings-Are-Value-Types）" class="headerlink" title="字符串是值类型（Strings Are Value Types）"></a>字符串是值类型（Strings Are Value Types）</h3><p>Swift 的 String 类型是值类型。 如果您创建了一个新的字符串，那么当其进行常量、变量赋值操作，或在函数&#x2F;方法中传递时，会进行值拷贝。 </p>
<blockquote>
<p>意思就是他们传递的时候也都是值传递，会比较安全，在传递的过程中不用担心会被更改</p>
</blockquote>
<h3 id="字符串插值-String-Interpolation"><a href="#字符串插值-String-Interpolation" class="headerlink" title="字符串插值 (String Interpolation)"></a>字符串插值 (String Interpolation)</h3><ul>
<li>插值字符串中写在括号中的表达式<strong>不能包含非转义双引号 ( “ ) 和反斜杠 ( \ )，并且不能包含回车或换行符</strong>。</li>
</ul>
<p>Todo:还有一些字符串操作的函数没有看</p>
<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><h4 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h4><p>Swift 中的 Array 类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（ count ）和适当类型的初始值（ repeatedValue ）传入数组构造函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDoubles <span class="operator">=</span> [<span class="type">Double</span>](count: <span class="number">3</span>, repeatedValue:<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// threeDoubles 是一种 [Double]数组, 等于 [0.0, 0.0, 0.0]</span></span><br></pre></td></tr></table></figure>

<h4 id="通过两个数组相加创建一个数组"><a href="#通过两个数组相加创建一个数组" class="headerlink" title="通过两个数组相加创建一个数组"></a>通过两个数组相加创建一个数组</h4><p>我们可以使用加法操作符（ + ）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherThreeDoubles <span class="operator">=</span> <span class="type">Array</span>(count: <span class="number">3</span>, repeatedValue: <span class="number">2.5</span>)</span><br><span class="line"><span class="comment">// anotherThreeDoubles is inferred as [Double], and equals [2.5, 2.5, 2.5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sixDoubles <span class="operator">=</span> threeDoubles <span class="operator">+</span> anotherThreeDoubles</span><br><span class="line"><span class="comment">// sixDoubles 被推断为 [Double], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></span><br></pre></td></tr></table></figure>

<h4 id="使用加法赋值运算符（-x3D-）添加数据项"><a href="#使用加法赋值运算符（-x3D-）添加数据项" class="headerlink" title="使用加法赋值运算符（ +&#x3D; ）添加数据项"></a>使用加法赋值运算符（ +&#x3D; ）添加数据项</h4><p>使用加法赋值运算符（ +&#x3D; ）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Baking Powder&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有四项了</span></span><br><span class="line">shoppingList <span class="operator">+=</span> [<span class="string">&quot;Chocolate Spread&quot;</span>,<span class="string">&quot;Cheese&quot;</span>,<span class="string">&quot;Butter&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有七项了</span></span><br></pre></td></tr></table></figure>

<h4 id="使用下标访问数组"><a href="#使用下标访问数组" class="headerlink" title="使用下标访问数组"></a>使用下标访问数组</h4><p>可以利用下标来一次改变一系列数据值，<strong>即使新数据和原有数据的数量是不一样的</strong>。下面的例子把 “Chocolate Spread” ， “Cheese” ，和 “Butter” 替换为 “Bananas” 和  “Apples” ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shoppingList[<span class="number">4</span><span class="operator">...</span><span class="number">6</span>] <span class="operator">=</span> [<span class="string">&quot;Bananas&quot;</span>, <span class="string">&quot;Apples&quot;</span>]</span><br><span class="line"><span class="comment">// shoppingList 现在有六项</span></span><br></pre></td></tr></table></figure>



<h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h3><h4 id="基本集合操作"><a href="#基本集合操作" class="headerlink" title="基本集合操作"></a>基本集合操作</h4><p><img src="https://box.kancloud.cn/2015-08-11_55c98e2314bad.png" alt="2015-08-11_55c98e2314bad"></p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的 keys 或 values 属性使用 sort() 方法。</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>在 if 语句中，条件必须是一个布尔表达式，这意味着像 if score { … } 这样的代码将报错，而<strong>不会隐形地与 0 做对比</strong>。 你可以一起使用 if 和 let 来处理值缺失的情况，这些值可由可选值来代表。</p>
<p><strong>一个可选的值是一个具体的值或者是 nil 以表示值缺失</strong>，在类型后面加一个问号来标记这个变量的值是可选的。</p>
<p>如果不加这个问号的话就会导致比较报错，无法进行对比。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果这里不加?声明 optionalString 是一个可选值的话，第二行就会报错，提示变量没有初始化</span></span><br><span class="line"><span class="comment">//Variable &#x27;optionalString&#x27; used before being initialized</span></span><br><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String</span>?</span><br><span class="line"><span class="built_in">print</span>(optionalString <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> optionalName &#123;</span><br><span class="line">    greeting <span class="operator">=</span> <span class="string">&quot;Hello, <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> if let 就是把 ptionalName 值直接给一个临时常量，Swift会自动检测 optionalName 是否包含值，如果包含值，会隐式的拆包并给那个临时常量，在接下来的上下文中就能直接使用这个临时常量，这种方式称为**可选绑定（optional binding)**。 如果想要在后面操作可选值，可以定义为 if var  变量名，这样可选类型包含的值就会赋值给一个变量。</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul>
<li>运行 switch 中匹配到的子句之后，程序会退出 switch 语句，并不会继续向下运行，所以不需要在每个子句结尾写 break 。</li>
</ul>
<h4 id="区间匹配"><a href="#区间匹配" class="headerlink" title="区间匹配"></a>区间匹配</h4><p>可以使用…还有..&lt;来进行区间匹配。</p>
<h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>使用下划线（ _ ）来匹配所有可能的值，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="keyword">switch</span> somePoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(0, 0) is at the origin&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">_</span>, <span class="number">0</span>):</span><br><span class="line"><span class="operator">...</span></span><br></pre></td></tr></table></figure>

<h4 id="值绑定（Value-Bindings）"><a href="#值绑定（Value-Bindings）" class="headerlink" title="值绑定（Value Bindings）"></a>值绑定（Value Bindings）</h4><p>case 分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些常量或变量在该 case 分支里就可以被引用了——这种行为被称为_值绑定_（value binding）。</p>
<p>下面的例子展示了如何在一个 (Int, Int) 类型的元组中使用值绑定来分类下图中的点(x, y)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anotherPoint <span class="operator">=</span> (<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">switch</span> anotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="keyword">let</span> x, <span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the x-axis with an x value of <span class="subst">\(x)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;on the y-axis with a y value of <span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;somewhere else at (<span class="subst">\(x)</span>, <span class="subst">\(y)</span>)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;on the x-axis with an x value of 2&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="where"><a href="#where" class="headerlink" title="where"></a>where</h4><blockquote>
<p>还可以在do catch &#x2F; for &#x2F; 范型 &#x2F; 协议 结合使用</p>
</blockquote>
<blockquote>
<p>在类型名后面使用 where 来指定对类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类</p>
</blockquote>
<p>case 分支的模式可以使用 where 语句来判断额外的条件。</p>
<p>下面的例子把下图中的点(x, y)进行了分类：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yetAnotherPoint <span class="operator">=</span> (<span class="number">1</span>, <span class="operator">-</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">switch</span> yetAnotherPoint &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y) <span class="keyword">where</span> x <span class="operator">==</span> <span class="operator">-</span>y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is on the line x == -y&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(<span class="subst">\(x)</span>, <span class="subst">\(y)</span>) is just some arbitrary point&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;(1, -1) is on the line x == -y&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://box.kancloud.cn/2015-08-11_55c9902b7e35e.png" alt="2015-08-11_55c9902b7e35e"></p>
<h4 id="贯穿（Fallthrough）"><a href="#贯穿（Fallthrough）" class="headerlink" title="贯穿（Fallthrough）"></a>贯穿（Fallthrough）</h4><p>Swift 中的 switch不会从上一个 case 分支落入到下一个 case 分支中。相反，只要第一个匹配到的 case 分支完成了它需要执行的语句，整个  switch  代码块完成了它的执行。相比之下，C 语言要求你显示的插入  break  语句到每个  switch  分支的末尾来阻止自动落入到下一个 case 分支中。Swift 的这种避免默认落入到下一个分支中的特性意味着它的  switch  功能要比 C 语言的更加清晰和可预测，可以避免无意识地执行多个 case 分支从而引发的错误。</p>
<p>如果你确实需要 C 风格的贯穿的特性，你可以在每个需要该特性的 case 分支中使用  fallthrough  关键字。下面的例子使用  fallthrough  来创建一个数字的描述语句。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> integerToDescribe <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> description <span class="operator">=</span> <span class="string">&quot;The number <span class="subst">\(integerToDescribe)</span> is&quot;</span></span><br><span class="line"><span class="keyword">switch</span> integerToDescribe &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; a prime number, and also&quot;</span></span><br><span class="line">    <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    description <span class="operator">+=</span> <span class="string">&quot; an integer.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(description)</span><br><span class="line"><span class="comment">// 输出 &quot;The number 5 is a prime number, and also an integer.&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：    fallthrough   关键字不会检查它下一个将会落入执行的 case 中的匹配条件。   fallthrough   简单地使代码执行继续连接到下一个 case 中的执行代码，这和 C 语言标准中的   switch  语句特性是一样的。</p>
</blockquote>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>可以使用 for-in 来遍历字典，需要两个变量来表示每个键值对。</p>
<p>字典是一个无序的集合，所以他们的键和值以<strong>任意顺序</strong>迭代结束。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers <span class="operator">=</span> [</span><br><span class="line">    <span class="string">&quot;Prime&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">&quot;Fibonacci&quot;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&quot;Square&quot;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">_</span>, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number <span class="operator">&gt;</span> largest &#123;</span><br><span class="line">            largest <span class="operator">=</span> number</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest)</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><ul>
<li>while 循环的另外一种形式是 repeat-while ，它和 while 的区别是在判断循环条件之前，先执行一次循环的代码块，然后重复循环直到条件为 false 。<strong>这样可以保证一定可以执行一次循环</strong></li>
</ul>
<h3 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h3><p>像 if 语句一样，guard 的执行取决于一个表达式的布尔值。我们可以使用 guard 语句来要求条件必须为真时，以执行 guard 语句后的代码。不同于 if 语句，一个 guard 语句总是有一个 else 从句，如果条件不为真则执行 else 从句中的代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> name <span class="operator">=</span> person[<span class="string">&quot;name&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> location <span class="operator">=</span> person[<span class="string">&quot;location&quot;</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice near you.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I hope the weather is nice in <span class="subst">\(location)</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="检测-API-可用性"><a href="#检测-API-可用性" class="headerlink" title="检测 API 可用性"></a>检测 API 可用性</h3><p>Swift 内置支持检查 API 可用性，这可以确保我们不会在当前部署机器上，不小心地使用了不可用的 API。</p>
<p>我们在 <code>if</code> 或 <code>guard</code> 语句中使用 <code>可用性条件（availability condition)</code>去有条件的执行一段代码，来在运行时判断调用的 API 是否可用。编译器使用从可用性条件语句中获取的信息去验证，在这个代码块中调用的 API 是否可用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">10</span>, <span class="keyword">macOS</span> <span class="number">10.12</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">    <span class="comment">// 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用先前版本的 iOS 和 macOS 的 API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式和模式匹配"><a href="#模式和模式匹配" class="headerlink" title="模式和模式匹配"></a>模式和模式匹配</h3><p>模式代表单个值或者复合值的结构。<br>例如，元组 (1, 2) 的结构是由逗号分隔的，包含两个元素的列表。因为模式代表一种值的结 构，而不是特定的某个值，你可以利用模式来匹配各种各样的值。比如，(x, y) 可以匹配元 组 (1, 2)，以及任何含两个元素的元组。除了利用模式匹配一个值以外，你可以从复合值中提 取出部分或全部值，然后分别把各个部分的值和一个常量或变量绑定起来。</p>
<h4 id="表达式模式（Expression-Pattern）"><a href="#表达式模式（Expression-Pattern）" class="headerlink" title="表达式模式（Expression Pattern）"></a>表达式模式（Expression Pattern）</h4><p>重载 ~&#x3D; 运算符</p>
<h2 id="函数-x2F-x2F-todo"><a href="#函数-x2F-x2F-todo" class="headerlink" title="函数&#x2F;&#x2F;todo"></a>函数&#x2F;&#x2F;todo</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;Hello,&quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">  <span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用元组类型来实现多返回值的函数</li>
<li>还可以使用 (Int, Int)? 类似的来实现可选元组的返回类型。</li>
<li>如果整个函数体是一个单一表达式，那么函数隐式返回这个表达式，如下：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="string">&quot;Hello,&quot;</span> <span class="operator">+</span> person <span class="operator">+</span> <span class="string">&quot;!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数实际参数标签和形式参数名"><a href="#函数实际参数标签和形式参数名" class="headerlink" title="函数实际参数标签和形式参数名"></a>函数实际参数标签和形式参数名</h3><h4 id="实参标签和形参名"><a href="#实参标签和形参名" class="headerlink" title="实参标签和形参名"></a>实参标签和形参名</h4><p>Swift 引进参数标签（Argument Label）这个概念，主要应用在调用函数的情况，使得函数的实参与真实命名相关联，更加容易理解实参的意义</p>
<ul>
<li>在提供形式参数名之前写实际参数标签，用空格分隔。</li>
<li>如果你为一个形式参数提供了实际参数标签，那么这个实际参数就必须在调用函数的时候使用标签。</li>
<li><strong>实际参数标签的使用能够让函数的调用更加明确，更像是自然语句，同时还能提供更可读的函数体并更清晰地表达你的意图</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">greet</span>(<span class="params">person</span>: <span class="type">String</span>, <span class="params">from</span> <span class="params">hometown</span>: <span class="type">String</span>) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello <span class="subst">\(person)</span>! Glad you visit from <span class="subst">\(hometown)</span>.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(greet(person:<span class="string">&quot;Bill&quot;</span>, from: <span class="string">&quot;China&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>一个<em>可变参数（variadic parameter）</em>可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数。</p>
<p>可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</p>
<p>下面的这个函数用来计算一组任意长度数字的 *算术平均数（arithmetic mean)*：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func arithmeticMean(_ numbers: Double...) -&gt; Double &#123;</span><br><span class="line">    var total: Double = 0</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        total += number</span><br><span class="line">    &#125;</span><br><span class="line">    return total / Double(numbers.count)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(1, 2, 3, 4, 5)</span><br><span class="line">// 返回 3.0, 是这 5 个数的平均数。</span><br><span class="line">arithmeticMean(3, 8.25, 18.75)</span><br><span class="line">// 返回 10.0, 是这 3 个数的平均数。</span><br></pre></td></tr></table></figure>

<p>一个函数能拥有多个可变参数。可变参数后的第一个行参前必须加上实参标签。实参标签用于区分实参是传递给可变参数，还是后面的行参。</p>
<h3 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h3><p>函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为<em>输入输出参数（In-Out Parameters）</em>。</p>
<p>定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。一个 <code>输入输出参数</code>有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看 <a href="">输入输出参数</a> 一节。</p>
<p>你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加 <code>&amp;</code> 符，表示这个值可以被函数修改。</p>
<blockquote>
<p>注意</p>
<p>输入输出参数不能有默认值，而且可变参数不能用 <code>inout</code> 标记。</p>
</blockquote>
<p>下例中，<code>swapTwoInts(_:_:)</code> 函数有两个分别叫做 <code>a</code> 和 <code>b</code> 的输入输出参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">swapTwoInts</span>(<span class="keyword">_</span> <span class="params">a</span>: <span class="keyword">inout</span> <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="keyword">inout</span> <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>swapTwoInts(_:_:)</code> 函数简单地交换 <code>a</code> 与 <code>b</code> 的值。该函数先将 <code>a</code> 的值存到一个临时常量 <code>temporaryA</code> 中，然后将 <code>b</code> 的值赋给 <code>a</code>，最后将 <code>temporaryA</code> 赋值给 <code>b</code>。</p>
<p>你可以用两个 <code>Int</code> 型的变量来调用 <code>swapTwoInts(_:_:)</code>。需要注意的是，<code>someInt</code> 和 <code>anotherInt</code> 在传入 <code>swapTwoInts(_:_:)</code> 函数前，都加了 <code>&amp;</code> 的前缀：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> anotherInt <span class="operator">=</span> <span class="number">107</span></span><br><span class="line">swapTwoInts(<span class="operator">&amp;</span>someInt, <span class="operator">&amp;</span>anotherInt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;someInt is now <span class="subst">\(someInt)</span>, and anotherInt is now <span class="subst">\(anotherInt)</span>&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“someInt is now 107, and anotherInt is now 3”</span></span><br></pre></td></tr></table></figure>

<p>从上面这个例子中，我们可以看到 <code>someInt</code> 和 <code>anotherInt</code> 的原始值在 <code>swapTwoInts(_:_:)</code> 函数中被修改，尽管它们的定义在函数体外。</p>
<blockquote>
<p>注意</p>
<p>输入输出参数和返回值是不一样的。上面的 <code>swapTwoInts</code> 函数并没有定义任何返回值，但仍然修改了 <code>someInt</code> 和 <code>anotherInt</code> 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</p>
</blockquote>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>对于原始集合的每个元素，作用于当前累积的结果上</p>
<h4 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h4><p>对于元素是集合的集合，可以得到单级的集合</p>
<p>（flat 水平的）</p>
<h4 id="compactmap"><a href="#compactmap" class="headerlink" title="compactmap"></a>compactmap</h4><p>过滤空值</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">10</span> &#125;)</span><br><span class="line"><span class="comment">//[10, 20, 40, 60, 100]</span></span><br><span class="line"><span class="built_in">print</span>(numbers.filter &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="number">3</span> &#125;)</span><br><span class="line"><span class="comment">//[4, 6, 10]</span></span><br><span class="line"><span class="built_in">print</span>(numbers.reduce(<span class="number">100</span>) &#123; <span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span> &#125;)</span><br><span class="line"><span class="comment">//123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayNumbers <span class="operator">=</span> [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="built_in">print</span>(arrayNumbers.flatMap &#123; <span class="variable">$0</span>.map &#123; <span class="variable">$0</span> <span class="operator">*</span> <span class="number">10</span> &#125;&#125;)</span><br><span class="line"><span class="comment">//[10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nnames:[<span class="type">String</span>?] <span class="operator">=</span> [<span class="string">&quot;zhangsan&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;lisi&quot;</span>, <span class="literal">nil</span>, <span class="string">&quot;wangwu&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(nnames.compactMap &#123; <span class="variable">$0</span> &#125;)</span><br><span class="line"><span class="comment">//[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]</span></span><br></pre></td></tr></table></figure>



<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>有一个名字列表，其中一些条目由单个字符构成。现在任务是，将除去单字符条目之外的列表内容，放在一个逗号分隔的字符串里返回，且每个名字的首字母都要大写。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> employee <span class="operator">=</span> [<span class="string">&quot;wss&quot;</span>, <span class="string">&quot;lxy&quot;</span>, <span class="string">&quot;xx&quot;</span>, <span class="string">&quot;xy&quot;</span>, <span class="string">&quot;gg&quot;</span>, <span class="string">&quot;z&quot;</span>, <span class="string">&quot;niuniu&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;x&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令式解法</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">cleanNames</span>(<span class="params">names</span>: [<span class="type">String</span>]) -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> cleanNames <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">        <span class="keyword">if</span> name.count <span class="operator">&gt;</span> <span class="number">1</span> &#123;</span><br><span class="line">            cleanNames <span class="operator">+=</span> name.capitalized <span class="operator">+</span> <span class="string">&quot;,&quot;</span><span class="comment">//首字母大写</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cleanNames.remove(at: cleanNames.index(before: cleanNames.endIndex))<span class="comment">//去除末尾的逗号</span></span><br><span class="line">    <span class="keyword">return</span> cleanNames</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cleanNames(names: employee))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式解法</span></span><br><span class="line"><span class="keyword">let</span> cleanNames2 <span class="operator">=</span> employee.filter&#123; <span class="variable">$0</span>.count <span class="operator">&gt;</span> <span class="number">1</span> &#125;.map&#123; <span class="variable">$0</span>.capitalized &#125;.joined(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cleanNames2)</span><br></pre></td></tr></table></figure>



<h2 id="闭包-x2F-x2F-todo"><a href="#闭包-x2F-x2F-todo" class="headerlink" title="闭包&#x2F;&#x2F;todo"></a>闭包&#x2F;&#x2F;todo</h2><p>在 函数章节中介绍的全局和嵌套函数实际上也是特殊的闭包，闭包采用如下三种形式之一：</p>
<ul>
<li>全局函数是一个有名字但不会捕获任何值的闭包</li>
<li>嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包</li>
<li>闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包</li>
</ul>
<p>Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，主要优化如下：</p>
<ul>
<li>利用上下文推断参数和返回值类型</li>
<li>隐式返回单表达式闭包，即单表达式闭包可以省略 <code>return</code> 关键字</li>
<li>参数名称缩写</li>
<li>尾随闭包语法</li>
</ul>
<h3 id="闭包表达式"><a href="#闭包表达式" class="headerlink" title="闭包表达式"></a>闭包表达式</h3><p>下面的闭包表达式示例使用 <code>sorted(by:)</code> 方法对一个 <code>String</code> 类型的数组进行字母逆序排序。以下是初始数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Chris&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Ewa&quot;</span>, <span class="string">&quot;Barry&quot;</span>, <span class="string">&quot;Daniella&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><code>sorted(by:)</code> 方法接受一个闭包，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值<em>前面</em>，排序闭包函数需要返回 <code>true</code>，反之返回 <code>false</code>。</p>
<p>该例子对一个 <code>String</code> 类型的数组进行排序，因此排序闭包函数类型需为 <code>(String, String) -&gt; Bool</code>。</p>
<p>提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 <code>sorted(by:)</code> 方法的参数传入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">backward</span>(<span class="keyword">_</span> <span class="params">s1</span>: <span class="type">String</span>, <span class="keyword">_</span> <span class="params">s2</span>: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> reversedNames <span class="operator">=</span> names.sorted(by: backward)</span><br><span class="line"><span class="comment">// reversedNames 为 [&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h4><p>闭包表达式语法有如下的一般形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; <span class="keyword">return</span> type <span class="keyword">in</span></span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>闭包表达式参数</em> 可以是 in-out 参数，但不能设定默认值。如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。</p>
<p>下面的例子展示了之前 <code>backward(_:_:)</code> 函数对应的闭包表达式版本的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>内联闭包表达式中，函数和返回值类型都写在<em>大括号内</em>，而不是大括号外，改写为一行代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; (s1: <span class="type">String</span>, s2: <span class="type">String</span>) -&gt; <span class="type">Bool</span> <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>

<h4 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h4><p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> <span class="keyword">return</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>

<h4 id="单表达式闭包的隐式返回"><a href="#单表达式闭包的隐式返回" class="headerlink" title="单表达式闭包的隐式返回"></a>单表达式闭包的隐式返回</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; s1, s2 <span class="keyword">in</span> s1 <span class="operator">&gt;</span> s2 &#125; )</span><br></pre></td></tr></table></figure>

<h4 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125; )</span><br></pre></td></tr></table></figure>

<h4 id="运算符方法"><a href="#运算符方法" class="headerlink" title="运算符方法"></a>运算符方法</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted(by: <span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someFunctionThatTakesAClosure</span>(<span class="params">closure</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是不使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是使用尾随闭包进行函数调用</span></span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <a href="">闭包表达式语法</a> 上章节中的字符串排序闭包可以作为尾随包的形式改写在 <code>sorted(by:)</code> 方法圆括号的外面：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted() &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 <code>()</code> 省略掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames <span class="operator">=</span> names.sorted &#123; <span class="variable">$0</span> <span class="operator">&gt;</span> <span class="variable">$1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>当闭包非常长以至于不能在一行中进行书写时，尾随闭包变得非常有用。</p>
<h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><p>默认情况下，闭包会捕获附近作用域的常量和变量，并使用强引用指向他们。可以用一个捕获列表来显示的指定这个捕获行为。</p>
<p>一旦使用了捕获列表，就必须要用**<code>in</code>**关键字，即使已经省略了参数名和返回类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> closure <span class="operator">=</span> &#123; [a] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">b <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 打印“0 10”</span></span><br></pre></td></tr></table></figure>

<p>在示例中，变量 <code>b</code> 只有一个，然而，变量 <code>a</code> 有两个，一个在闭包外，一个在闭包内。闭包内的变量 <code>a</code> 会在闭包创建时用闭包外的变量 <code>a</code> 的值来初始化，除此之外它们并无其他联系。</p>
<p>但是下面这个<code>x</code>，虽然有两个，但是因为他们是引用类型，都指向了同一个实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x <span class="operator">=</span> <span class="type">SimpleClass</span>()</span><br><span class="line"><span class="keyword">var</span> y <span class="operator">=</span> <span class="type">SimpleClass</span>()</span><br><span class="line"><span class="keyword">let</span> closure <span class="operator">=</span> &#123; [x] <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(x.value, y.value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">x.value <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">y.value <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 打印“10 10”</span></span><br></pre></td></tr></table></figure>

<p>如果捕获列表中的值是类类型，你可以使用 <code>weak</code> 或者 <code>unowned</code> 来修饰它，闭包会分别用弱引用和无主引用来捕获该值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myFunction &#123; <span class="built_in">print</span>(<span class="keyword">self</span>.title) &#125;                    <span class="comment">// 隐式强引用捕获</span></span><br><span class="line">myFunction &#123; [<span class="keyword">self</span>] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="keyword">self</span>.title) &#125;         	<span class="comment">// 显式强引用捕获</span></span><br><span class="line">myFunction &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="keyword">self</span><span class="operator">!</span>.title) &#125;    <span class="comment">// 弱引用捕获</span></span><br><span class="line">myFunction &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="keyword">self</span>.title) &#125;  <span class="comment">// 无主引用捕获</span></span><br></pre></td></tr></table></figure>

<p>在捕获列表中，也可以将任意表达式的值绑定到一个常量上。该表达式会在闭包被创建时进行求值，闭包会按照指定的引用类型来捕获表达式的值。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以弱引用捕获 self.parent 并赋值给 parent</span></span><br><span class="line">myFunction &#123; [<span class="keyword">weak</span> parent <span class="operator">=</span> <span class="keyword">self</span>.parent] <span class="keyword">in</span> <span class="built_in">print</span>(parent<span class="operator">!</span>.title) &#125;</span><br></pre></td></tr></table></figure>



<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>每个枚举都定义了一个全新的类型。正如 Swift 中其它的类型那样，它们的名称(例如: CompassPoint和 Planet)需要<strong>首字母大写</strong>。给枚举类型起一个单数的而不是复数的名字，从 而使得它们能够顾名思义。</p>
<h3 id="遍历枚举的-case"><a href="#遍历枚举的-case" class="headerlink" title="遍历枚举的 case"></a>遍历枚举的 case</h3><p>对于某些枚举来说，如果能有一个集合包含了枚举的所有情况就好了。你可以通过在枚举名字后面写 : CaseIterable 来允许枚举被遍历。Swift 会暴露一个包含对应枚举类型所有情况的集合名为 allCases。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> : <span class="title class_">CaseIterable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> south</span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">CompassPoint</span>.allCases.count)</span><br></pre></td></tr></table></figure>

<h4 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h4><p>枚举成员可以用相同类型的默认值预先填充(称为原始值)。</p>
<p>当你在操作存储整数或字符串原始值枚举的时候，你不必显式地给每一个成员都分配一个原始值。当你没有分配时，Swift 将会自动为你分配值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">CompassPoint</span> : <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> south <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> north</span><br><span class="line">    <span class="keyword">case</span> east</span><br><span class="line">    <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="type">CompassPoint</span>.north.rawValue)</span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="从原始值初始化"><a href="#从原始值初始化" class="headerlink" title="从原始值初始化"></a>从原始值初始化</h4><p>如果用原始值类型来定义一个枚举，那么枚举就会自动收到一个可以接受原始值类型的值的构造器(叫做 rawValue的形式参数)然后返回一个枚举成员或者 nil </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> direction <span class="operator">=</span> <span class="type">CompassPoint</span>(rawValue: <span class="number">4</span>)</span><br><span class="line"><span class="comment">//west</span></span><br><span class="line"><span class="keyword">let</span> direction2 <span class="operator">=</span> <span class="type">CompassPoint</span>(rawValue: <span class="number">5</span>)</span><br><span class="line"><span class="comment">//nil</span></span><br></pre></td></tr></table></figure>

<h4 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h4><p>可以定义 Swift 枚举来存储任意给定类型的关联值，如果需要的话不同枚举成员关联值的类型 可以不同。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Barcode</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> upc(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> qrCode(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productCode <span class="operator">=</span> <span class="type">Barcode</span>.upc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(productCode)</span><br><span class="line"><span class="keyword">var</span> productCode2 <span class="operator">=</span> <span class="type">Barcode</span>.qrCode(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> productCode2 &#123;</span><br><span class="line"><span class="keyword">case</span> .upc(<span class="keyword">let</span> a, <span class="keyword">let</span> b, <span class="keyword">let</span> c, <span class="keyword">let</span> d):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upc: <span class="subst">\(a)</span>, <span class="subst">\(b)</span>, <span class="subst">\(c)</span>, <span class="subst">\(d)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .qrCode(<span class="keyword">let</span> codeString):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;qrcode:&quot;</span> <span class="operator">+</span> codeString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h2><h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>存储属性要么是变量存储属性(由 var 关键字引入)要么是常量存储属性(由 let 关键字引入)。</p>
<p><strong>常量结构体实例的存储属性：</strong>如果创建了一个结构体的实例并且把这个实例赋给常量，你不能修改这个实例的属性，即使是声明为变量的属性。</p>
<h3 id="延迟存储属性"><a href="#延迟存储属性" class="headerlink" title="延迟存储属性"></a>延迟存储属性</h3><p>延迟存储属性的初始值在其第一次使用时才进行计算。可以通过在其声明前标注 lazy 修饰语来表示一个延迟存储属性。如果被标记为 lazy 修饰符的属性同时被多个线程访问并且属性还没有被初始化，则无法保证属性只初始化一次。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>类，结构体和枚举也能够定义计算属性，计算属性<strong>不存储值</strong>，它提供一个getter和一个setter</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> centerX <span class="operator">=</span> origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">let</span> centerY <span class="operator">=</span> origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter) &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newCenter.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newCenter.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简写setter"><a href="#简写setter" class="headerlink" title="简写setter"></a>简写setter</h4><p>如果一个计算属性的setter没有为将要被设置的值定义一个名字，那么它将被默认命名为newValue</p>
<h4 id="简写-getter"><a href="#简写-getter" class="headerlink" title="简写 getter"></a>简写 getter</h4><p>如果整个 getter 的函数体是一个单一的表达式，那么 getter 隐式返回这个表达式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="type">Point</span>(x: origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>), y: origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            origin.x <span class="operator">=</span> newValue.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            origin.y <span class="operator">=</span> newValue.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="只读计算属性"><a href="#只读计算属性" class="headerlink" title="只读计算属性"></a>只读计算属性</h4><p>一个有 getter 但是没有 setter 的计算属性就是所谓的只读计算属性。只读计算属性返回一个值，也可以通过点语法访问，但是不能被修改为另一个值。<strong>所以必须要用var关键字来定义计算属性（包括只读计算属性）</strong>因为它们的值不是固定的。 let 关键字只用于常量属性，用于明确那些值一旦作为实例初始化就不能更改。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> center: <span class="type">Point</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">Point</span>(x: origin.x <span class="operator">+</span> (size.width <span class="operator">/</span> <span class="number">2</span>), y: origin.y <span class="operator">+</span> (size.height <span class="operator">/</span> <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h3><p>willSet 会在该值被<strong>存储之前</strong>被调用。 didSet 会在一个新值被<strong>存储之后</strong>被调用。</p>
<p>如果你现了一个 willSet 观察者，新的属性值会以常量形式参数传递。可以在 willSet 实现中为这个参数定义名字。如果没有为它命名，那么它会使用默认的名字 newValue 。</p>
<p>如果实现了一个 didSet观察者，一个包含旧属性值的常量形式参数将会被传递。可以为它命名，也可以使用默认的形式参数名 oldValue 。</p>
<p>观察属性的能力同样对全局变量和局部变量有效。全局变量是定义在任何函数、方法、闭包或者类型环境之外的变量。局部变量是定义在函数、方法或者闭包环境之中的变量。</p>
<h3 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h3><p>可以给类型本身也定义属性，和实例的存储属性不同，实例之间的属性相互独立，而类型属性则只有一份，无论创建了多少个该类新的实例，都会是这个。</p>
<p>类型属性用于定义某个类型所有实例共享的数据，比如所有实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</p>
<p>存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</p>
<blockquote>
<p>注意:<br>跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是<strong>延迟初始化</strong>的，它们只有在<strong>第一次被访问的时候才会被初始化</strong>。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用  lazy  修饰符。</p>
</blockquote>
<p>使用 static 关键字来定义类型属性。对于类类型的计算类型属性，你可以使用 class 关键字 来允许子类重写父类的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> storedTypeProperty <span class="operator">=</span> <span class="string">&quot;Some value.&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> computedTypeProperty: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">27</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">var</span> <span class="title class_">overrideableComputedTypeProperty</span>: <span class="title class_">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">107</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>不用显式的写出self，swift会假定调用了当前实例中的属性或方法<br>但是如果一个实例方法的形式参数名与实例中某个属性拥有相同的名字的时候，这个时候<strong>形式参数名具有优先权</strong>，所以要加上self来区分形式参数名和属性名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">isToTheRightOf</span>(<span class="params">x</span>: <span class="type">Double</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x <span class="operator">&gt;</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">4.0</span>, y: <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">if</span> aPoint.isToTheRightOf(x: <span class="number">1.0</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;isRight&quot;</span>)</span><br><span class="line">    <span class="comment">//isRight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="在实例方法中修改属性"><a href="#在实例方法中修改属性" class="headerlink" title="在实例方法中修改属性"></a>在实例方法中修改属性</h3><p>结构体和枚举是<strong>值类型</strong>，默认情况下，值类型属性不能被自身的实例方法修改。</p>
<p>但是可以在 func 关键字前放一个 mutating 关键字来指定方可以修改属性。</p>
<blockquote>
<p>关于mutating 可以看看<a target="_blank" rel="noopener" href="https://www.swiftbysundell.com/articles/mutating-and-nonmutating-swift-contexts/">这篇</a></p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">      x <span class="operator">+=</span> deltaX</span><br><span class="line">      y <span class="operator">+=</span> deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> point(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="在-mutating-方法中赋值给-self"><a href="#在-mutating-方法中赋值给-self" class="headerlink" title="在 mutating 方法中赋值给 self"></a>在 mutating 方法中赋值给 self</h4><p>Mutating 方法可以指定整个实例给隐含的 self 属性</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">moveBy</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Double</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span> <span class="operator">=</span> point(x: <span class="number">3.0</span>, y: <span class="number">4.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> somePoint <span class="operator">=</span> point(x: <span class="number">1.0</span>, y: <span class="number">1.0</span>)</span><br><span class="line">somePoint.moveBy(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The Point is now at (<span class="subst">\(somePoint.x)</span>, <span class="subst">\(somePoint.y)</span>)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="枚举的-mutating-方法"><a href="#枚举的-mutating-方法" class="headerlink" title="枚举的 mutating 方法"></a>枚举的 mutating 方法</h4><p>枚举的 mutating 方法可以设置隐含的 self 属性为<strong>相同枚举里的不同成员</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">TriSwitch</span> &#123;</span><br><span class="line">  	<span class="keyword">case</span> off, low, high</span><br><span class="line">  	<span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">next</span>() &#123;</span><br><span class="line">  	  	<span class="keyword">switch</span> <span class="keyword">self</span>&#123;</span><br><span class="line"> 	    	<span class="keyword">case</span> .off:</span><br><span class="line">      		<span class="keyword">self</span> <span class="operator">=</span> .low</span><br><span class="line">    		<span class="keyword">case</span> .low:</span><br><span class="line">      		<span class="keyword">self</span> <span class="operator">=</span> .high</span><br><span class="line">    		<span class="keyword">case</span> .high</span><br><span class="line">      		<span class="keyword">self</span> <span class="operator">=</span> .off</span><br><span class="line">    		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> overLight <span class="operator">=</span> <span class="type">TriSwitch</span>.low</span><br><span class="line">overLight.next()</span><br><span class="line">overLight.next()</span><br></pre></td></tr></table></figure>

<h3 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h3><p>通过在 func关键字之前使用 static关键字来明确一个类型方法。类同样可以使用 class关键 字来允许子类重写父类对类型方法的实现。</p>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>类、结构体和枚举可以定义下标，它可以作为访问集合、列表或序列成员元素的快捷方式。</p>
<p>可以为一个类型定义多个下标，并且下标会基于传入的索引值的类型选择合适的下标重载使用。下标没有限制单个维度，你可以使用多个输入形参来定义下标以满足自定义类型的需求。</p>
<h3 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h3><p>使用关键字  subscript  来定义下标，并且指定一个或多个 输入形式参数和返回类型，与实例方法一样。与实例方法不同的是，下标可以是读写也可以 是只读的。<br>下标可以接收任意数量的输入形式参数，并且这些输入形式参数可以是任意类型。下标也可以返回任意类型。下标可以使用变量形式参数和可变形式参数，但是不能使用输入输出形式参数或提供默认形式参数值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">  	<span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">  	<span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">  	<span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    	<span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">    	<span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">    	grid <span class="operator">=</span> <span class="type">Array</span>(repeating: <span class="number">0.0</span>, count; rows <span class="operator">*</span> columns)</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">func</span> <span class="title function_">indexIsValid</span>(<span class="params">row</span>: <span class="type">Int</span>, sow <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">  	&#125;</span><br><span class="line"> 	  <span class="keyword">subscript</span> (row: <span class="type">Int</span>, column: <span class="type">Int</span>) -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    		<span class="keyword">get</span> &#123;</span><br><span class="line">     	 			assert(indexIsValid(row; row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">      			<span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">set</span> &#123;</span><br><span class="line">      			assert(indexIsValid(row: row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">      			grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">    		&#125; </span><br><span class="line">  	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那这个matrix长这样</span></span><br><span class="line">[<span class="number">0.0</span>  <span class="number">1.5</span>]</span><br><span class="line">[<span class="number">3.2</span>  <span class="number">0.0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="类型下标"><a href="#类型下标" class="headerlink" title="类型下标"></a>类型下标</h3><p>通过在 subscript 关键字前加 static 关键字来标 记类型下标。在类里则使用 class 关键字，这样可以允许子类重写父类的下标实现。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>在 Swift 中，类可以调用和访问超类的方法、属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。</p>
<p>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>
<h3 id="定义一个基类"><a href="#定义一个基类" class="headerlink" title="定义一个基类"></a>定义一个基类</h3><p>不继承于其它类的类，称之为基类。</p>
<h3 id="子类生成"><a href="#子类生成" class="headerlink" title="子类生成"></a>子类生成</h3><p><em>子类生成</em>指的是在一个已有类的基础上创建一个新的类。子类继承超类的特性，并且可以进一步完善。你还可以为子类添加新的特性。</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类可以为继承来的实例方法，类方法，实例属性，类属性，或下标提供自己定制的实现。我们把这种行为叫<em>重写</em>。</p>
<h4 id="重写属性"><a href="#重写属性" class="headerlink" title="重写属性"></a>重写属性</h4><h5 id="重写属性的-getters-和-setters"><a href="#重写属性的-getters-和-setters" class="headerlink" title="重写属性的 getters 和 setters"></a>重写属性的 getters 和 setters</h5><p>你可以提供定制的 getter（或 setter）来重写任何一个继承来的属性，无论这个属性是存储型还是计算型属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必须将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。</p>
<p>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，<strong>不可以将一个继承来的读写属性重写为一个只读属性。</strong></p>
<blockquote>
<p>注意</p>
<p>如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过 <code>super.someProperty</code> 来返回继承来的值，其中 <code>someProperty</code> 是你要重写的属性的名字。</p>
</blockquote>
<p>以下的例子定义了一个新类，叫 <code>Car</code>，它是 <code>Vehicle</code> 的子类。这个类引入了一个新的存储型属性叫做 <code>gear</code>，默认值为整数 <code>1</code>。<code>Car</code> 类重写了继承自 <code>Vehicle</code> 的 <code>description</code> 属性，提供包含当前档位的自定义描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Car: Vehicle &#123;</span><br><span class="line">    var gear = 1</span><br><span class="line">    override var description: String &#123;</span><br><span class="line">        return super.description + &quot; in gear \(gear)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写的 <code>description</code> 属性首先要调用 <code>super.description</code> 返回 <code>Vehicle</code> 类的 <code>description</code> 属性。之后，<code>Car</code> 类版本的 <code>description</code> 在末尾增加了一些额外的文本来提供关于当前档位的信息。</p>
<p>如果你创建了 <code>Car</code> 的实例并且设置了它的 <code>gear</code> 和 <code>currentSpeed</code> 属性，你可以看到它的 <code>description</code> 返回了 <code>Car</code> 中的自定义描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let car = Car()</span><br><span class="line">car.currentSpeed = 25.0</span><br><span class="line">car.gear = 3</span><br><span class="line">print(&quot;Car: \(car.description)&quot;)</span><br><span class="line">// 打印“Car: traveling at 25.0 miles per hour in gear 3”</span><br></pre></td></tr></table></figure>

<h5 id="重写属性观察器"><a href="#重写属性观察器" class="headerlink" title="重写属性观察器"></a>重写属性观察器</h5><p>可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，无论被继承属性原本是如何实现的，当其属性值发生改变时，你就会被通知到。关于属性观察器的更多内容，请看 <a href="">属性观察器</a>。</p>
<blockquote>
<p>注意</p>
<p>不可以为继承来的<strong>常量存储型属性</strong>或继承来的<strong>只读计算型属性</strong>添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供 <code>willSet</code> 或 <code>didSet</code> 实现也是不恰当。</p>
</blockquote>
<blockquote>
<p>注意</p>
<p>不可以同时提供重写的 setter 和重写的属性观察者。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>
</blockquote>
<p>下面的例子定义了一个新类叫 <code>AutomaticCar</code>，它是 <code>Car</code> 的子类。<code>AutomaticCar</code> 表示自动档汽车，它可以根据当前的速度自动选择合适的档位:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class AutomaticCar: Car &#123;</span><br><span class="line">    override var currentSpeed: Double &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            gear = Int(currentSpeed / 10.0) + 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你设置 <code>AutomaticCar</code> 的 <code>currentSpeed</code> 属性，属性的 <code>didSet</code> 观察器就会自动地设置 <code>gear</code> 属性，为新的速度选择一个合适的档位。具体来说就是，属性观察器将新的速度值除以 <code>10</code>，然后向下取得最接近的整数值，最后加 <code>1</code> 来得到档位 <code>gear</code> 的值。例如，速度为 <code>35.0</code> 时，档位为 <code>4</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let automatic = AutomaticCar()</span><br><span class="line">automatic.currentSpeed = 35.0</span><br><span class="line">print(&quot;AutomaticCar: \(automatic.description)&quot;)</span><br><span class="line">// 打印“AutomaticCar: traveling at 35.0 miles per hour in gear 4”</span><br></pre></td></tr></table></figure>

<h4 id="防止重写"><a href="#防止重写" class="headerlink" title="防止重写"></a>防止重写</h4><p>可以通过把方法，属性或下标标记为 <em><code>final</code></em> 来防止它们被重写，只需要在声明关键字前加上 <code>final</code> 修饰符即可</p>
<p>可以通过在关键字 <code>class</code> 前添加 <code>final</code> 修饰符（<code>final class</code>）来将整个类标记为 final 。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>
<h2 id="类的构造过程"><a href="#类的构造过程" class="headerlink" title="类的构造过程"></a>类的构造过程</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器在创建特定类型的实例时被调用。</p>
<h4 id="默认的属性值和构造器"><a href="#默认的属性值和构造器" class="headerlink" title="默认的属性值和构造器"></a>默认的属性值和构造器</h4><p>可以指定一个默认属性值作为属性声明的一部分。当属性被定义的时候你可以通过为这个属性分配一个初始值来指定默认的属性值。</p>
<p>Swift 为所有没有提供构造器的结构体或类提供了一个默认的构造器来给所有的属性提供了默认值。这个默认的构造器只是简单地创建了一个所有属性都有默认值的新实例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShoppingListItem</span> &#123;</span><br><span class="line">  	<span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">		<span class="keyword">var</span> quantity <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">var</span> purchased <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> item <span class="operator">=</span> <span class="type">ShoppingListItem</span>()</span><br></pre></td></tr></table></figure>

<h4 id="自定义构造"><a href="#自定义构造" class="headerlink" title="自定义构造"></a>自定义构造</h4><p>可以提供构造形式参数作为构造器的一部分，来定义构造过程中的类型和值的名称。<br>构造形式参数与函数和方法的形式参数具有相同的功能和语法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Celsius</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temperatureInCelsius: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromFahrenheit</span> <span class="params">fahrenheit</span>: <span class="type">Double</span>)</span><br><span class="line">  	  	temperatureInCelsius<span class="operator">=</span> (fahrenheit <span class="operator">-</span> <span class="number">32.0</span>) <span class="operator">/</span> <span class="number">1.8</span></span><br><span class="line">	  &#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">fromKelvin</span> <span class="params">kelvin</span>: <span class="type">Double</span>) &#123;</span><br><span class="line">      	temperatureInCelsius <span class="operator">=</span> kelvin <span class="operator">-</span> <span class="number">273.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boilingPointofWater <span class="operator">=</span> <span class="type">Celsius</span>(fromFahrenheit: <span class="number">212.0</span>)</span><br><span class="line"><span class="keyword">let</span> freezingPointofWater <span class="operator">=</span> <span class="type">Celsius</span>(fromKelvin: <span class="number">273.15</span>)</span><br></pre></td></tr></table></figure>

<h4 id="在初始化中分配常量属性"><a href="#在初始化中分配常量属性" class="headerlink" title="在初始化中分配常量属性"></a>在初始化中分配常量属性</h4><p>在初始化的任意时刻，你都可以给常量属性赋值，<strong>只要它在初始化结束是设置了确定的值即可</strong>。<br><strong>一旦为常量属性被赋值，它就不能再被修改了</strong>。</p>
<h4 id="结构体的成员初始化构造器"><a href="#结构体的成员初始化构造器" class="headerlink" title="结构体的成员初始化构造器"></a>结构体的成员初始化构造器</h4><p>如果结构体类型中没有定义任何自定义构造器，它会自动获得一个成员构造器。不同于默认构造器，<strong>结构体会接收成员构造器即使它的存储属性没有默认值</strong>。</p>
<h4 id="值类型的构造器委托"><a href="#值类型的构造器委托" class="headerlink" title="值类型的构造器委托"></a>值类型的构造器委托</h4><p>就是值类型的构造器中可以调用其他构造器来执行部分实例的初始化。这个过程，就是所谓的构造器委托，避免了多个构造器里冗余代码。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Size</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width <span class="operator">=</span> <span class="number">0.0</span>, height <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> origin <span class="operator">=</span> <span class="type">Point</span> ()</span><br><span class="line">    <span class="keyword">var</span> size <span class="operator">=</span> <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">origin</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">    		<span class="keyword">self</span>.origin <span class="operator">=</span> origin</span><br><span class="line">    		<span class="keyword">self</span>.size <span class="operator">=</span> size</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">init</span>(<span class="params">center</span>: <span class="type">Point</span>, <span class="params">size</span>: <span class="type">Size</span>) &#123;</span><br><span class="line">    		<span class="keyword">let</span> origin <span class="operator">=</span> center.x <span class="operator">-</span> (size.width <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">  			<span class="keyword">let</span> origin <span class="operator">=</span> center.y <span class="operator">-</span> (size.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">  			<span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originx, y: originY), size: size)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类的构造过程-1"><a href="#类的构造过程-1" class="headerlink" title="类的构造过程"></a>类的构造过程</h3><ul>
<li>所有类的存储属性(包括从它的父类继承的所有属性)都必须在初始化期间分配初始值。</li>
<li>Swift 为类类型定义了两种构造器以<strong>确保所有的存储属性接收一个初始值</strong>。</li>
<li>指定构造器是类的主要构造器。指定的构造器可以<strong>初始化所有那个类引用的属性并且调用合适的父类构造器</strong>来继续这个初始化过程给父类链。</li>
<li>类偏向于少量指定构造器，并且一个类通常只有一个指定构造器。指定构造器是初始化开始并持续初始化过程到父类链的“传送”点。</li>
<li><strong>每个类至少得有一个指定构造器</strong>。如同在构造器的自动继承里描述的那样，在某些情况下，这些需求<strong>通过从父类继承一个或多个指定构造器</strong>来满足。</li>
<li>便捷构造器是次要的。可以在相同的类里定义一个便捷构造器来调用一个指定的构造器作为便捷构造器来给指定构造器设置默认形式参数。你也可以为具体的使用情况或输入的值类型定义一个便捷构造器从而创建这个类的实例。</li>
<li>如果类不需要便捷构造器你可以不提供它。在为通用的初始化模式创建快捷方式以节省时间或者类的初始化更加清晰明了的时候使用便捷构造器。</li>
</ul>
<h4 id="指定构造器"><a href="#指定构造器" class="headerlink" title="指定构造器"></a>指定构造器</h4><p>用与值类型的简单构造器相同的方式来写类的指定构造器。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="便捷构造器"><a href="#便捷构造器" class="headerlink" title="便捷构造器"></a>便捷构造器</h4><p>用<code>convenicence</code>修饰符放到<code>init</code>关键字前定义便捷构造器</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenicence <span class="keyword">init</span>(paramenters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类的初始化委托"><a href="#类的初始化委托" class="headerlink" title="类的初始化委托"></a>类的初始化委托</h4><ul>
<li>指定构造器必须从它的直系父类调用指定构造器。</li>
<li>便捷构造器必须从相同的类里调用<strong>另一个构造器</strong>。（便捷构造器没办法直接调用父类的构造器</li>
<li><strong>便捷构造器最终必须调用一个指定构造器。</strong></li>
</ul>
<blockquote>
<p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是<em>向上</em>代理</li>
<li>便利构造器必须总是<em>横向</em>代理</li>
</ul>
</blockquote>
<img src="https://i.loli.net/2021/08/26/FvOknEqfCbxGoJw.png" alt="截屏2021-08-26 下午4.51.24" style="zoom:67%;" />



<h4 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h4><img src="https://i.loli.net/2021/08/26/ewfr4ICdycFlMJW.jpg" alt="IMG_3180" style="zoom: 33%;" />

<p>Swift 中类的构造过程包含两个阶段。第一个阶段，类中的每个存储型属性赋一个初始值。当每个存储型属性的初始值被赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步自定义它们的存储型属性。</p>
<p>两段式初始化过程的使用让初始化更加安全，同时在每个类的层级结构给与了完备的灵活性。两段式初始化过程可以防止属性值在初始化之前被访问，还可以防止属性值被另一个构造器意外地赋予不同的值。</p>
<h5 id="安全检查"><a href="#安全检查" class="headerlink" title="安全检查"></a>安全检查</h5><p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：</p>
<ol>
<li>指定构造器必须保证在向上委托给父类构造器之前，其所在类引入的所有属性都要初始化完成。</li>
<li>指定构造器必须先向上委托父类构造器，然后才能为继承的属性设置新值。如果不这样做， 指定构造器赋予的新值将被父类中的构造器所覆盖。</li>
<li>便捷构造器必须先委托同类中的其它构造器，然后再为任意属性赋新值(包括同类里定义的 属性)。如果没这么做，便捷构构造器赋予的新值将被自己类中其它指定构造器所覆盖。（其实也就是<code>self.init</code>必须位于属性访问，属性赋值之前，通常位于第一行）</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也 不能引用 self 作为值。</li>
</ol>
<h5 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h5><ul>
<li><p>类的某个指定构造器或便利构造器被调用。</p>
</li>
<li><p>完成类的新实例内存的分配，但此时内存还没有被初始化。</p>
</li>
<li><p>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</p>
</li>
<li><p>指定构造器切换到父类的构造器，对其存储属性完成相同的任务。</p>
</li>
<li><p>这个过程沿着类的继承链一直往上执行，直到到达继承链的最顶部。</p>
</li>
<li><p>当到达了继承链最顶部，而且继承链的最后一个类已确保所有的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</p>
</li>
</ul>
<h5 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h5><ul>
<li><p>从继承链顶部往下，继承链中每个类的指定构造器都有机会进一步自定义实例。构造器此时可以访问 self、修改它的属性并调用实例方法等等。</p>
</li>
<li><p>最终，继承链中任意的便利构造器有机会自定义实例和使用 self。</p>
</li>
</ul>
<p>下图展示了在假定的子类和父类之间的构造阶段 1：</p>
<p><img src="https://i.loli.net/2021/08/26/4wYxHob7AdZKaNi.png" alt="img"></p>
<p>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时还不能修改任何属性，它会代理到该类中的指定构造器。</p>
<p>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着继承链一直往上完成父类的构造过程。</p>
<p>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。</p>
<p><strong>一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化</strong>，阶段 1 完成。</p>
<p>以下展示了相同构造过程的阶段 2：</p>
<p><img src="https://i.loli.net/2021/08/26/1lJIPOnfyTMRFvu.png" alt="img"></p>
<p>父类中的指定构造器现在有机会进一步自定义实例（尽管这不是必须的）。</p>
<p>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的自定义操作（这也不是必须的）。</p>
<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的自定义操作。</p>
<h4 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h4><p><strong>子类在默认情况下不会继承父类的构造器</strong>。但是如果满足特定条件，父类构造器是可以被自动继承的。事实上，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则将适用：</p>
<ol>
<li>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。</li>
<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了<strong>自定义实现</strong>——它将自动继承父类所有的便利构造器。</li>
</ol>
<blockquote>
<p>注意！</p>
<p>子类可以将父类的指定构造器实现为便利构造器来满足规则2</p>
</blockquote>
<p>即使在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<h4 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h4><p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号（init?）。<br>可失败构造器会创建一个类型为自身类型的可选类型的对象。通过 return nil 语句来表明可失败构造器在何种情况下应该 “失败”。<br>通常来说我们通过在 init 关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在 init 后面添加感叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。<br>你可以在 init? 中代理到 init!，反之亦然。你也可以用 init? 重写 init!，反之亦然。你还可以用 init 代理到 init!，不过，一旦 init! 构造失败，则会触发一个断言。</p>
<h4 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h4><p>在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 <code>required</code> 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubclass</span>: <span class="title class_">SomeClass</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造器的实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。</p>
</blockquote>
<h4 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h4><p>如果某个存储型属性的默认值需要一些自定义或设置，可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被构造时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>
<blockquote>
<p>注意：</p>
<p>如果使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着不能在闭包里访问其它属性，即使这些属性有默认值。同样，也不能使用隐式的 <code>self</code> 属性，或者调用任何实例方法。</p>
</blockquote>
<h2 id="类的析构过程"><a href="#类的析构过程" class="headerlink" title="类的析构过程"></a>类的析构过程</h2><p><em>析构器</em>只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字 <code>deinit</code> 来标示，类似于构造器要用 <code>init</code> 来标示。</p>
<h3 id="析构过程原理"><a href="#析构过程原理" class="headerlink" title="析构过程原理"></a>析构过程原理</h3><p>Swift 会自动释放不再需要的实例以释放资源。如 <a href="">自动引用计数</a> 章节中所讲述，Swift 通过<em>自动引用计数（ARC)</em> 处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>
<p>在类的定义中，每个类<strong>最多只能有一个析构器</strong>，而且析构器不带任何参数和圆括号，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="comment">// 执行析构过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>析构器是在实例释放发生前被自动调用的。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>
<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换在 Swift 中使用 <code>is</code> 和 <code>as</code> 操作符实现。</p>
<p>先为下面的实例代码定义类层次：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MediaItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>: <span class="title class_">MediaItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> director: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">director</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.director <span class="operator">=</span> director</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Song</span>: <span class="title class_">MediaItem</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> artist: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">artist</span>: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.artist <span class="operator">=</span> artist</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义了 MediaItem 的两个子类。第一个子类 Movie 在父类的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器</span></span><br><span class="line"><span class="keyword">let</span> library <span class="operator">=</span> [</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">&quot;Casablanca&quot;</span>, director: <span class="string">&quot;Michael Curtiz&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;Blue Suede Shoes&quot;</span>, artist: <span class="string">&quot;Elvis Presley&quot;</span>),</span><br><span class="line">    <span class="type">Movie</span>(name: <span class="string">&quot;Citizen Kane&quot;</span>, director: <span class="string">&quot;Orson Welles&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;The One And Only&quot;</span>, artist: <span class="string">&quot;Chesney Hawkes&quot;</span>),</span><br><span class="line">    <span class="type">Song</span>(name: <span class="string">&quot;Never Gonna Give You Up&quot;</span>, artist: <span class="string">&quot;Rick Astley&quot;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 数组 library 的类型被推断为 [MediaItem]</span></span><br></pre></td></tr></table></figure>

<h3 id="检查类型"><a href="#检查类型" class="headerlink" title="检查类型"></a>检查类型</h3><p>用<em>类型检查操作符</em>（<code>is</code>）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> movieCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> songCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        movieCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> item <span class="keyword">is</span> <span class="type">Song</span> &#123;</span><br><span class="line">        songCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Media library contains <span class="subst">\(movieCount)</span> movies and <span class="subst">\(songCount)</span> songs&quot;</span>)</span><br><span class="line"><span class="comment">// “Media library contains 2 movies and 3 songs”</span></span><br></pre></td></tr></table></figure>

<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，可以尝试用<em>类型转换操作符</em>（<code>as?</code> 或 <code>as!</code>）向下转到它的子类型。</p>
<p>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式 <code>as?</code> 返回一个你试图向下转成的类型的可选值，如果不能向下转型，那么这个可选值将是<code>nil</code>。强制形式 <code>as!</code> 把试图向下转型和强制解包转换结果结合为一个操作，如果向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> library &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> movie <span class="operator">=</span> item <span class="keyword">as?</span> <span class="type">Movie</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Movie: <span class="subst">\(movie.name)</span>, dir. <span class="subst">\(movie.director)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> song <span class="operator">=</span> item <span class="keyword">as?</span> <span class="type">Song</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Song: <span class="subst">\(song.name)</span>, by <span class="subst">\(song.artist)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Movie: Casablanca, dir. Michael Curtiz</span></span><br><span class="line"><span class="comment">// Song: Blue Suede Shoes, by Elvis Presley</span></span><br><span class="line"><span class="comment">// Movie: Citizen Kane, dir. Orson Welles</span></span><br><span class="line"><span class="comment">// Song: The One And Only, by Chesney Hawkes</span></span><br><span class="line"><span class="comment">// Song: Never Gonna Give You Up, by Rick Astley</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>
</blockquote>
<h3 id="Any-和-AnyObject-的类型转换"><a href="#Any-和-AnyObject-的类型转换" class="headerlink" title="Any 和 AnyObject 的类型转换"></a><code>Any</code> 和 <code>AnyObject</code> 的类型转换</h3><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<ul>
<li><code>Any</code> 可以表示任何类型，包括函数类型。</li>
<li><strong><code>AnyObject</code></strong> 可以表示任何类类型的实例。</li>
</ul>
<h2 id="嵌套类型（Nested-Types）"><a href="#嵌套类型（Nested-Types）" class="headerlink" title="嵌套类型（Nested Types）"></a>嵌套类型（Nested Types）</h2><p>就是一个类型里面可以套其他类型，Swift 允许你定义<em>嵌套类型</em>，可以在支持的类型中定义嵌套的枚举、类和结构体。要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的 <code>&#123;&#125;</code> 内，而且可以根据需要定义多级嵌套。</p>
<h2 id="扩展（extension）"><a href="#扩展（extension）" class="headerlink" title="扩展（extension）"></a>扩展（extension）</h2><p>扩展可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力（即逆向建模）。</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型实例属性(computed instance properties )和计算型类属性(computed instance properties )</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使已经存在的类型遵循（conform）一个协议</li>
</ul>
<p>在 Swift 中，你甚至可以扩展协议以提供其需要的实现(implementations)，或者添加额外功能给遵循的类型所使用。</p>
<blockquote>
<p>注意</p>
<p>扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能。</p>
</blockquote>
<h3 id="拓展的语法"><a href="#拓展的语法" class="headerlink" title="拓展的语法"></a>拓展的语法</h3><p>使用 <code>extension</code> 关键字声明扩展</p>
<blockquote>
<p>注意</p>
<p>对一个现有的类型，如果你定义了一个扩展来添加新的功能，那么这个类型的所有实例都可以使用这个新功能，包括那些在扩展定义之前就存在的实例。</p>
</blockquote>
<h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><p>扩展可以给现有类型添加计算型实例属性和计算型类属性。这个例子给 Swift 内建的 <code>Double</code> 类型添加了五个计算型实例属性，从而提供与距离单位相关工作的基本支持：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Double</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> ft: <span class="type">Double</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> <span class="operator">/</span> <span class="number">3.28084</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> oneInch <span class="operator">=</span> <span class="number">25.4</span>.mm</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One inch is <span class="subst">\(oneInch)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“One inch is 0.0254 meters”</span></span><br><span class="line"><span class="keyword">let</span> threeFeet <span class="operator">=</span> <span class="number">3</span>.ft</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Three feet is <span class="subst">\(threeFeet)</span> meters&quot;</span>)</span><br><span class="line"><span class="comment">// 打印“Three feet is 0.914399970739201 meters”</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 </p>
<p>扩展可以添加新的计算属性，但是它们不能添加存储属性，或向现有的属性添加属性观察者。</p>
</blockquote>
<h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>扩展可以给现有的类型添加新的构造器。对于值类型，他可以添加一个简单构造器，但是对于类类型，只能添加便利构造器，不能添加新的指定构造器或者析构器，指定构造器和析构器必须始终由类的原始实现提供。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>扩展可以给现有类型添加新的实例方法和类方法。</p>
<p>在下面的例子中，给 <code>Int</code> 类型添加了一个新的实例方法叫做 <code>repetitions</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">repetitions</span>(<span class="params">task</span>: () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span><span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>repetitions(task:)</code> 方法仅接收一个 <code>() -&gt; Void</code> 类型的参数，它表示一个没有参数没有返回值的方法。</p>
<p>定义了这个扩展之后，你可以对任意整形数值调用 <code>repetitions(task:)</code> 方法，来执行对应次数的任务：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.repetitions &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里用尾随闭包省略了参数标签和（）</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br><span class="line"><span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<h4 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h4><p>将这个实例方法标记为 <code>mutating</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">func</span> <span class="title function_">square</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span> <span class="operator">*</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someInt <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">someInt.square()</span><br></pre></td></tr></table></figure>

<h3 id="下标-1"><a href="#下标-1" class="headerlink" title="下标"></a>下标</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Int</span> &#123;</span><br><span class="line">    <span class="keyword">subscript</span>(<span class="params">digitIndex</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> decimalBase <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">..&lt;</span>digitIndex &#123;</span><br><span class="line">            decimalBase <span class="operator">*=</span> <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span> <span class="operator">/</span> decimalBase) <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">746381295</span>[<span class="number">0</span>]<span class="comment">// 返回 5</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">1</span>]<span class="comment">// 返回 9</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">2</span>]<span class="comment">// 返回 2</span></span><br><span class="line"><span class="number">746381295</span>[<span class="number">8</span>]<span class="comment">// 返回 7</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>扩展可以给现有的类，结构体，还有枚举添加新的嵌套类型</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h3><p>协议不指定属性是存储属性还是计算属性，它只指定属性的名称和类型，还有这个属性是可读的还是可读可写的。</p>
<p>如果协议要求这个属性是可读可写的，那遵循这个协议的时候这个属性就不能是常量属性或者只读的计算属性。</p>
<p>如果协议只要求这个属性是可读的，那这个属性其实不止可读，如果代码需要的话它还可以可写，这也就是为什么不说只读而说可读的原因。</p>
<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>&#123; set get &#125;</code> 来表示属性是<em>可读可写</em>的，<em>可读</em>属性则用 <code>&#123; get &#125;</code> 来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    var mustBeSettable: Int &#123; get set &#125;</span><br><span class="line">    var doesNotNeedToBeSettable: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型<strong>遵循协议</strong>时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h3><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。但是不支持为协议中的方法指定默认参数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">someTypeMethod</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和属性要求一样，在协议中定义方法时，<strong>总是使用 <code>static</code> 关键字作为前缀，在类实现的时候，可以使用<code>class</code>来作为关键字前缀</strong>。</p>
<h3 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h3><p>实现协议中的 <code>mutating</code> 方法时，若是类类型，则不用写 <code>mutating</code> 关键字。而对于结构体和枚举，则必须写 <code>mutating</code> 关键字。（结构体和枚举是<strong>值类型</strong>，默认情况下，值类型属性不能被自身的实例方法修改。）</p>
<h3 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h3><p>可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="headerlink" title="协议构造器要求的类实现"></a>协议构造器要求的类实现</h4><p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeClass</span>: <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(<span class="params">someParameter</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>required</code> 修饰符可以确保所有子类也必须提供此构造器实现，从而也能遵循协议。</p>
<blockquote>
<p>注意</p>
<p>如果类已经被标记为 <code>final</code>，那么不需要在协议构造器的实现中使用 <code>required</code> 修饰符，因为 <code>final</code> 类不能有子类。</p>
</blockquote>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSuperClass</span> &#123;</span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeSubClass</span>: <span class="title class_">SomeSuperClass</span>, <span class="title class_">SomeProtocol</span> &#123;</span><br><span class="line">    <span class="operator">/</span> 因为遵循协议，需要加上 <span class="keyword">required</span></span><br><span class="line">    <span class="comment">// 因为继承自父类，需要加上 override</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// 这里是构造器的实现部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可失败构造器要求"><a href="#可失败构造器要求" class="headerlink" title="可失败构造器要求"></a>可失败构造器要求</h4><p>协议还可以为遵循协议的类型定义可失败构造器要求，详见 <a href="">可失败构造器</a>。<br>遵循协议的类型可以通过可失败构造器（<code>init?</code>）或非可失败构造器（<code>init</code>）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（<code>init</code>）或隐式解包可失败构造器（<code>init!</code>）来满足。</p>
<h3 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h3><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个功能完备的类型来使用。协议作为类型使用，有时被称作「存在类型」，这个名词来自「存在着一个类型 T，该类型遵循协议 T」。</p>
<p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<blockquote>
<p>注意</p>
<p>协议是一种类型，因此协议类型的名称应与其他类型（例如 <code>Int</code>，<code>Double</code>，<code>String</code>）的写法相同，使用大写字母开头的驼峰式写法，例如（<code>FullyNamed</code> 和 <code>RandomNumberGenerator</code>）。</p>
</blockquote>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p><em>委托</em>是一种设计模式，它允许类或结构体<strong>将一些需要它们负责的功能委托给其他类型的实例</strong>。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<h3 id="在扩展里添加协议遵循"><a href="#在扩展里添加协议遵循" class="headerlink" title="在扩展里添加协议遵循"></a>在扩展里添加协议遵循</h3><blockquote>
<p>通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>
</blockquote>
<h3 id="在扩展里声明采纳协议-Declaring-Protocol-Adoption-with-an-Extension"><a href="#在扩展里声明采纳协议-Declaring-Protocol-Adoption-with-an-Extension" class="headerlink" title="在扩展里声明采纳协议(Declaring Protocol Adoption with an Extension)"></a>在扩展里声明采纳协议(Declaring Protocol Adoption with an Extension)</h3><p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明采纳该协议时，可以<strong>通过空的扩展来让它采纳该协议</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Hamster</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">       <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A hamster named <span class="subst">\(name)</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Hamster</span>: <span class="title class_">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>从现在起，<code>Hamster</code> 的实例可以作为 <code>TextRepresentable</code> 类型使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> simonTheHamster <span class="operator">=</span> <span class="type">Hamster</span>(name: <span class="string">&quot;Simon&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> somethingTextRepresentable: <span class="type">TextRepresentable</span> <span class="operator">=</span> simonTheHamster</span><br><span class="line"><span class="built_in">print</span>(somethingTextRepresentable.textualDescription)</span><br><span class="line"><span class="comment">// 打印 “A hamster named Simon”</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p>
</blockquote>
<h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>泛型类型可能只在某些情况下满足一个协议的要求，比如当类型的泛型形式参数遵循对应协议时。你可以通过在扩展类型时列出限制让泛型类型有条件地遵循某协议。在你采纳协议的名字后面写泛型 <code>where</code> 分句。更多关于泛型 <code>where</code> 分句，见 <a href="">泛型 Where 分句</a>。</p>
<p>下面的扩展让 <code>Array</code> 类型只要在存储遵循 <code>TextRepresentable</code> 协议的元素时就遵循 <code>TextRepresentable</code> 协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span>: <span class="title class_">TextRepresentable</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">TextRepresentable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> textualDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemsAsText <span class="operator">=</span> <span class="keyword">self</span>.map &#123; <span class="variable">$0</span>.textualDescription &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> <span class="operator">+</span> itemsAsText.joined(separator: <span class="string">&quot;, &quot;</span>) <span class="operator">+</span> <span class="string">&quot;]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDice <span class="operator">=</span> [d6, d12]</span><br><span class="line"><span class="built_in">print</span>(myDice.textualDescription)</span><br><span class="line"><span class="comment">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用合成实现来采纳协议-Adopting-a-Protocol-Using-a-Synthesized-Implementation"><a href="#使用合成实现来采纳协议-Adopting-a-Protocol-Using-a-Synthesized-Implementation" class="headerlink" title="使用合成实现来采纳协议(Adopting a Protocol Using a Synthesized Implementation)"></a>使用合成实现来采纳协议(Adopting a Protocol Using a Synthesized Implementation)</h3><p>Swift 可以自动提供一些简单场景下遵循 <code>Equatable</code>、<code>Hashable</code> 和 <code>Comparable</code> 协议的实现。在使用这些合成实现之后，无需再编写重复的代码来实现这些协议所要求的方法。</p>
<p>Swift 为以下几种自定义类型提供了 <code>Equatable</code> 协议的合成实现：</p>
<ul>
<li>遵循 <code>Equatable</code> 协议且只有存储属性的结构体。</li>
<li>遵循 <code>Equatable</code> 协议且只有关联类型的枚举</li>
<li>没有任何关联类型的枚举</li>
</ul>
<p>在包含类型原始声明的文件中声明对 <code>Equatable</code> 协议的遵循，可以得到 <code>==</code> 操作符的合成实现，且无需自己编写任何关于 <code>==</code> 的实现代码。<code>Equatable</code> 协议同时包含 <code>!=</code> 操作符的默认实现。</p>
<p>下面的例子中定义了一个 <code>Vector3D</code> 结构体来表示一个类似 <code>Vector2D</code> 的三维向量 <code>(x, y, z)</code>。由于 <code>x</code>、<code>y</code> 和 <code>z</code> 都是满足 <code>Equatable</code> 的类型，<code>Vector3D</code> 可以得到连等判断的合成实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vector3D</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="operator">=</span> <span class="number">0.0</span>, y <span class="operator">=</span> <span class="number">0.0</span>, z <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> twoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">let</span> anotherTwoThreeFour <span class="operator">=</span> <span class="type">Vector3D</span>(x: <span class="number">2.0</span>, y: <span class="number">3.0</span>, z: <span class="number">4.0</span>)</span><br><span class="line"><span class="keyword">if</span> twoThreeFour <span class="operator">==</span> anotherTwoThreeFour &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;These two vectors are also equivalent.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;These two vectors are also equivalent.&quot;</span></span><br></pre></td></tr></table></figure>

<p>Swift 为以下几种自定义类型提供了 <code>Hashable</code> 协议的合成实现：</p>
<ul>
<li>遵循 <code>Hashable</code> 协议且只有存储属性的结构体。</li>
<li>遵循 <code>Hashable</code> 协议且只有关联类型的枚举</li>
<li>没有任何关联类型的枚举</li>
</ul>
<p>在包含类型原始声明的文件中声明对 <code>Hashable</code> 协议的遵循，可以得到 <code>hash(into:)</code> 的合成实现，且无需自己编写任何关于 <code>hash(into:)</code> 的实现代码。</p>
<p>Swift 为没有原始值的枚举类型提供了 <code>Comparable</code> 协议的合成实现。如果枚举类型包含关联类型，那这些关联类型也必须同时遵循 <code>Comparable</code> 协议。在包含原始枚举类型声明的文件中声明其对 <code>Comparable</code> 协议的遵循，可以得到 <code>&lt;</code> 操作符的合成实现，且无需自己编写任何关于 <code>&lt;</code> 的实现代码。<code>Comparable</code> 协议同时包含 <code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 操作符的默认实现。</p>
<p>下面的例子中定义了 <code>SkillLevel</code> 枚举类型，其中定义了初学者（beginner）、中级（intermediate）和专家（expert）三种等级，专家等级会由额外的星级（stars）来进行排名。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SkillLevel</span>: <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> beginner</span><br><span class="line">    <span class="keyword">case</span> intermediate</span><br><span class="line">    <span class="keyword">case</span> expert(stars: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> levels <span class="operator">=</span> [<span class="type">SkillLevel</span>.intermediate, <span class="type">SkillLevel</span>.beginner,</span><br><span class="line">              <span class="type">SkillLevel</span>.expert(stars: <span class="number">5</span>), <span class="type">SkillLevel</span>.expert(stars: <span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> level <span class="keyword">in</span> levels.sorted() &#123;</span><br><span class="line">    <span class="built_in">print</span>(level)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;beginner&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;intermediate&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 3)&quot;</span></span><br><span class="line"><span class="comment">// 打印 &quot;expert(stars: 5)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h3><p>通过添加 <code>AnyObject</code> 关键字到协议的继承列表，就可以限制协议只能被类类型采纳（以及非结构体或者非枚举的类型）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">SomeClassOnlyProtocol</span>: <span class="title class_">AnyObject</span>, <span class="title class_">SomeInheritedProtocol</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是类专属协议的定义部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上例子中，协议 <code>SomeClassOnlyProtocol</code> 只能被类类型采纳。如果尝试让结构体或枚举类型采纳 <code>SomeClassOnlyProtocol</code>，则会导致编译时错误。</p>
<blockquote>
<p>Swift 为不确定类型提供了两种特殊的类型别名：</p>
<ul>
<li><code>Any</code> 可以表示任何类型，包括函数类型。</li>
<li><strong><code>AnyObject</code></strong> 可以表示任何类类型的实例。</li>
</ul>
</blockquote>
<blockquote>
<p>注意</p>
<p>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。</p>
</blockquote>
<h3 id="协议组合（Composition），协议合成"><a href="#协议组合（Composition），协议合成" class="headerlink" title="协议组合（Composition），协议合成"></a>协议组合（Composition），协议合成</h3><p>协议组合就是使用<code>&amp;</code>来组合多个协议到一个要求里，它还可以使用<code> typealias</code> 关键字来定义别名，可以不定义新的协议类型的同时，拥有构成中所有协议的需求。</p>
<p>详见协议组合小章节</p>
<h3 id="检查协议一致性-Checking-for-Protocol-Conformance"><a href="#检查协议一致性-Checking-for-Protocol-Conformance" class="headerlink" title="检查协议一致性(Checking for Protocol Conformance)"></a>检查协议一致性(Checking for Protocol Conformance)</h3><p>可以使用 类型转换 中描述的 <code>is</code> 和 <code>as</code> 操作符来检查协议一致性，即是否遵循某协议，并且可以转换到指定的协议类型。检查和转换协议的语法与检查和转换类型是完全一样的：</p>
<ul>
<li><code>is</code> 用来检查实例是否遵循某个协议，若遵循则返回 <code>true</code>，否则返回 <code>false</code>；</li>
<li><code>as?</code> 返回一个可选值，当实例遵循某个协议时，返回类型为协议类型的可选值，否则返回 <code>nil</code>；</li>
<li><code>as!</code> 将实例强制向下转换到某个协议类型，如果强转失败，将触发运行时错误。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>: <span class="title class_">A</span>, <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> test()</span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> (instance <span class="keyword">as</span> <span class="type">A</span>).bar()</span><br><span class="line"><span class="comment">//这里不使用类型转化就会报bar的调用有歧义</span></span><br></pre></td></tr></table></figure>

<h3 id="可选的协议要求-x2F-x2F-todo"><a href="#可选的协议要求-x2F-x2F-todo" class="headerlink" title="可选的协议要求&#x2F;&#x2F;todo"></a>可选的协议要求&#x2F;&#x2F;todo</h3><p>协议可以定义<em>可选要求</em>，遵循协议的类型可以选择是否实现这些要求。在协议中使用 <code>optional</code> 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上 <code>@objc</code> 属性。</p>
<p>标记 <code>@objc</code> 特性的协议只能被继承自 Objective-C 类的类或者 <code>@objc</code> 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>
<p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 <code>(Int) -&gt; String</code> 的方法会变成 <code>((Int) -&gt; String)?</code>。需要注意的是整个函数类型是可选的，而不是函数的返回值。</p>
<p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 <code>someOptionalMethod?(someArgument)</code> 这样，你可以在可选方法名称后加上 <code>?</code> 来调用可选方法。详细内容可在 <a href="">可选链式调用</a> 章节中查看。</p>
<p>下面的例子定义了一个名为 <code>Counter</code> 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 <code>CounterDataSource</code> 协议定义，它包含两个可选要求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol CounterDataSource &#123;</span><br><span class="line">    @objc optional func increment(forCount count: Int) -&gt; Int</span><br><span class="line">    @objc optional var fixedIncrement: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CounterDataSource</code> 协议定义了一个可选方法 <code>increment(forCount:)</code> 和一个可选属性 <code>fiexdIncrement</code>，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<blockquote>
<p>注意</p>
<p>严格来讲，<code>CounterDataSource</code> 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求，尽管技术上允许这样做，不过最好不要这样写。</p>
</blockquote>
<h3 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h3><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。<br>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现而无需任何额外修改<br>协议扩展可以为遵循协议的类型增加实现，但<strong>不能声明该协议继承自另一个协议</strong>。<br><strong>协议的继承只能在协议声明处进行指定。</strong></p>
<h4 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h4><p>可以通过协议扩展来为协议要求的方法、计算属性提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。</p>
<blockquote>
<p>注意</p>
<p>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<h4 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="headerlink" title="为协议扩展添加限制条件"></a>为协议扩展添加限制条件</h4><p>举个例子，可以扩展 <code>Collection</code> 协议，适用于集合中的元素遵循了 <code>Equatable</code> 协议的情况。通过限制集合元素遵循 <code>Equatable</code> 协议， 作为标准库的一部分， 你可以使用 <code>==</code> 和 <code>!=</code> 操作符来检查两个元素的等价性和非等价性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> <span class="title class_">Collection</span> <span class="title class_">where</span> <span class="title class_">Element</span>: <span class="title class_">Equatable</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">allEqual</span>() -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> element <span class="operator">!=</span> <span class="keyword">self</span>.first &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果集合中的所有元素都一致，<code>allEqual()</code> 方法才返回 <code>true</code>。</p>
<p>看看两个整数数组，一个数组的所有元素都是一样的，另一个不一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(equalNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;true&quot;</span></span><br><span class="line"><span class="built_in">print</span>(differentNumbers.allEqual())</span><br><span class="line"><span class="comment">// 打印 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>如果一个遵循的类型满足了为同一方法或属性提供实现的多个限制型扩展的要求， Swift 会使用最匹配限制的实现。</p>
</blockquote>
<p>泛型</p>
<p>不透明类型</p>
<p>自动引用计数</p>
<p>内存安全</p>
<p>访问控制</p>
<p>高级运算符</p>
<p>可选链</p>
<p>错误处理</p>
<p>并发</p>
<p>类型转换</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Swift-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-Numeric-Type-Conversion"><span class="nav-number">1.0.1.</span> <span class="nav-text">数值型类型转换(Numeric Type Conversion)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D-type-aliases"><span class="nav-number">1.0.2.</span> <span class="nav-text">类型别名(type aliases)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B-bool"><span class="nav-number">1.0.3.</span> <span class="nav-text">布尔类型(bool)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84-tuples"><span class="nav-number">1.0.4.</span> <span class="nav-text">元组(tuples)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B-optionals"><span class="nav-number">1.0.5.</span> <span class="nav-text">可选类型(optionals)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%A7%A3%E6%9E%90-forced-unwrapping"><span class="nav-number">1.0.6.</span> <span class="nav-text">强制解析(forced unwrapping)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%BB%91%E5%AE%9A-optional-binding"><span class="nav-number">1.0.7.</span> <span class="nav-text">可选绑定(optional binding)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%A7%A3%E6%9E%90%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B-implicitly-unwrapped-optionals"><span class="nav-number">1.0.8.</span> <span class="nav-text">隐式解析可选类型(implicitly unwrapped optionals)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">基本运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6-Nil-Coalescing-Operator"><span class="nav-number">1.1.1.</span> <span class="nav-text">空合运算符(Nil Coalescing Operator)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">区间运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">字符串和字符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88String-Literals%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">字符串字面量（String Literals）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%88Strings-Are-Value-Types%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">字符串是值类型（Strings Are Value Types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC-String-Interpolation"><span class="nav-number">1.2.3.</span> <span class="nav-text">字符串插值 (String Interpolation)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">数组（Array）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">创建一个带有默认值的数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E5%8A%A0%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">通过两个数组相加创建一个数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8A%A0%E6%B3%95%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-x3D-%EF%BC%89%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">使用加法赋值运算符（ +&#x3D; ）添加数据项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">使用下标访问数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88-Set"><span class="nav-number">1.3.2.</span> <span class="nav-text">集合(Set)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">基本集合操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">1.3.3.</span> <span class="nav-text">字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="nav-number">1.4.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">1.4.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch"><span class="nav-number">1.4.2.</span> <span class="nav-text">switch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%8C%B9%E9%85%8D"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">区间匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E7%BB%84%EF%BC%88Tuple%EF%BC%89"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">元组（Tuple）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%BB%91%E5%AE%9A%EF%BC%88Value-Bindings%EF%BC%89"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">值绑定（Value Bindings）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#where"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">where</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%AF%E7%A9%BF%EF%BC%88Fallthrough%EF%BC%89"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">贯穿（Fallthrough）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for"><span class="nav-number">1.4.3.</span> <span class="nav-text">for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while"><span class="nav-number">1.4.4.</span> <span class="nav-text">while</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#guard"><span class="nav-number">1.4.5.</span> <span class="nav-text">guard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B-API-%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">1.4.6.</span> <span class="nav-text">检测 API 可用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.4.7.</span> <span class="nav-text">模式和模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%BC%8F%EF%BC%88Expression-Pattern%EF%BC%89"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">表达式模式（Expression Pattern）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-x2F-x2F-todo"><span class="nav-number">1.5.</span> <span class="nav-text">函数&#x2F;&#x2F;todo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E9%99%85%E5%8F%82%E6%95%B0%E6%A0%87%E7%AD%BE%E5%92%8C%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E5%90%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">函数实际参数标签和形式参数名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E5%8F%82%E6%A0%87%E7%AD%BE%E5%92%8C%E5%BD%A2%E5%8F%82%E5%90%8D"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">实参标签和形参名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.2.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="nav-number">1.5.3.</span> <span class="nav-text">输入输出参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.4.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatmap"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">flatmap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compactmap"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">compactmap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">函数式编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85-x2F-x2F-todo"><span class="nav-number">1.6.</span> <span class="nav-text">闭包&#x2F;&#x2F;todo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">闭包表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">闭包表达式语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%8B%E6%96%87%E6%8E%A8%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">根据上下文推断类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%97%AD%E5%8C%85%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">单表达式闭包的隐式返回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0%E7%BC%A9%E5%86%99"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">参数名称缩写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">运算符方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BE%E9%9A%8F%E9%97%AD%E5%8C%85"><span class="nav-number">1.6.2.</span> <span class="nav-text">尾随闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="nav-number">1.6.3.</span> <span class="nav-text">捕获列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.7.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">1.7.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%9E%9A%E4%B8%BE%E7%9A%84-case"><span class="nav-number">1.7.2.</span> <span class="nav-text">遍历枚举的 case</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E5%80%BC"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">原始值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">从原始值初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%80%BC"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">关联值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.</span> <span class="nav-text">添加属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.1.</span> <span class="nav-text">存储属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%AD%98%E5%82%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.2.</span> <span class="nav-text">延迟存储属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.3.</span> <span class="nav-text">计算属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%86%99setter"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">简写setter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%86%99-getter"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">简写 getter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">只读计算属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F%E8%80%85"><span class="nav-number">1.8.4.</span> <span class="nav-text">属性观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">1.8.5.</span> <span class="nav-text">类型属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.</span> <span class="nav-text">添加方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.1.</span> <span class="nav-text">实例方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7"><span class="nav-number">1.9.2.</span> <span class="nav-text">在实例方法中修改属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-mutating-%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B5%8B%E5%80%BC%E7%BB%99-self"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">在 mutating 方法中赋值给 self</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%9A%84-mutating-%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">枚举的 mutating 方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.3.</span> <span class="nav-text">类型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87"><span class="nav-number">1.10.</span> <span class="nav-text">下标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%AF%AD%E6%B3%95"><span class="nav-number">1.10.1.</span> <span class="nav-text">下标语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8B%E6%A0%87"><span class="nav-number">1.10.2.</span> <span class="nav-text">类型下标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.11.</span> <span class="nav-text">类的继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%B1%BB"><span class="nav-number">1.11.1.</span> <span class="nav-text">定义一个基类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E7%94%9F%E6%88%90"><span class="nav-number">1.11.2.</span> <span class="nav-text">子类生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%86%99"><span class="nav-number">1.11.3.</span> <span class="nav-text">重写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%B1%9E%E6%80%A7"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">重写属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%B1%9E%E6%80%A7%E7%9A%84-getters-%E5%92%8C-setters"><span class="nav-number">1.11.3.1.1.</span> <span class="nav-text">重写属性的 getters 和 setters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%B1%9E%E6%80%A7%E8%A7%82%E5%AF%9F%E5%99%A8"><span class="nav-number">1.11.3.1.2.</span> <span class="nav-text">重写属性观察器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B2%E6%AD%A2%E9%87%8D%E5%86%99"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">防止重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.12.</span> <span class="nav-text">类的构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.1.</span> <span class="nav-text">构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">默认的属性值和构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">自定义构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E5%88%86%E9%85%8D%E5%B8%B8%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">在初始化中分配常量属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.1.4.</span> <span class="nav-text">结构体的成员初始化构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E5%A7%94%E6%89%98"><span class="nav-number">1.12.1.5.</span> <span class="nav-text">值类型的构造器委托</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B-1"><span class="nav-number">1.12.2.</span> <span class="nav-text">类的构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">指定构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%BF%E6%8D%B7%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">便捷构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A7%94%E6%89%98"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">类的初始化委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E6%AE%B5%E5%BC%8F%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">两段式构造过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5"><span class="nav-number">1.12.2.4.1.</span> <span class="nav-text">安全检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B51"><span class="nav-number">1.12.2.4.2.</span> <span class="nav-text">阶段1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B52"><span class="nav-number">1.12.2.4.3.</span> <span class="nav-text">阶段2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">构造器的自动继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.2.6.</span> <span class="nav-text">可失败构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.12.2.7.</span> <span class="nav-text">必要构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E6%88%96%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">1.12.2.8.</span> <span class="nav-text">通过闭包或函数设置属性的默认值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.13.</span> <span class="nav-text">类的析构过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.1.</span> <span class="nav-text">析构过程原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="nav-number">1.14.</span> <span class="nav-text">可选链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.15.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.16.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.16.1.</span> <span class="nav-text">检查类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.16.2.</span> <span class="nav-text">向下转型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Any-%E5%92%8C-AnyObject-%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.16.3.</span> <span class="nav-text">Any 和 AnyObject 的类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B%EF%BC%88Nested-Types%EF%BC%89"><span class="nav-number">1.17.</span> <span class="nav-text">嵌套类型（Nested Types）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%88extension%EF%BC%89"><span class="nav-number">1.18.</span> <span class="nav-text">扩展（extension）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-number">1.18.1.</span> <span class="nav-text">拓展的语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="nav-number">1.18.2.</span> <span class="nav-text">计算型属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-1"><span class="nav-number">1.18.3.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.18.4.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.18.4.1.</span> <span class="nav-text">可变实例方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87-1"><span class="nav-number">1.18.5.</span> <span class="nav-text">下标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.18.6.</span> <span class="nav-text">嵌套类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.19.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A6%81%E6%B1%82"><span class="nav-number">1.19.1.</span> <span class="nav-text">属性要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%A6%81%E6%B1%82"><span class="nav-number">1.19.2.</span> <span class="nav-text">方法要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%8F%98%E6%96%B9%E6%B3%95%E8%A6%81%E6%B1%82"><span class="nav-number">1.19.3.</span> <span class="nav-text">异变方法要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E8%A6%81%E6%B1%82"><span class="nav-number">1.19.4.</span> <span class="nav-text">构造器要求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E5%99%A8%E8%A6%81%E6%B1%82%E7%9A%84%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.19.4.1.</span> <span class="nav-text">协议构造器要求的类实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%A4%B1%E8%B4%A5%E6%9E%84%E9%80%A0%E5%99%A8%E8%A6%81%E6%B1%82"><span class="nav-number">1.19.4.2.</span> <span class="nav-text">可失败构造器要求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.19.5.</span> <span class="nav-text">协议作为类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98"><span class="nav-number">1.19.6.</span> <span class="nav-text">委托</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%89%A9%E5%B1%95%E9%87%8C%E6%B7%BB%E5%8A%A0%E5%8D%8F%E8%AE%AE%E9%81%B5%E5%BE%AA"><span class="nav-number">1.19.7.</span> <span class="nav-text">在扩展里添加协议遵循</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%89%A9%E5%B1%95%E9%87%8C%E5%A3%B0%E6%98%8E%E9%87%87%E7%BA%B3%E5%8D%8F%E8%AE%AE-Declaring-Protocol-Adoption-with-an-Extension"><span class="nav-number">1.19.8.</span> <span class="nav-text">在扩展里声明采纳协议(Declaring Protocol Adoption with an Extension)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E9%81%B5%E5%BE%AA%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.19.9.</span> <span class="nav-text">有条件地遵循协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E6%88%90%E5%AE%9E%E7%8E%B0%E6%9D%A5%E9%87%87%E7%BA%B3%E5%8D%8F%E8%AE%AE-Adopting-a-Protocol-Using-a-Synthesized-Implementation"><span class="nav-number">1.19.10.</span> <span class="nav-text">使用合成实现来采纳协议(Adopting a Protocol Using a Synthesized Implementation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%B8%93%E5%B1%9E%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.19.11.</span> <span class="nav-text">类专属的协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%EF%BC%88Composition%EF%BC%89%EF%BC%8C%E5%8D%8F%E8%AE%AE%E5%90%88%E6%88%90"><span class="nav-number">1.19.12.</span> <span class="nav-text">协议组合（Composition），协议合成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%8D%8F%E8%AE%AE%E4%B8%80%E8%87%B4%E6%80%A7-Checking-for-Protocol-Conformance"><span class="nav-number">1.19.13.</span> <span class="nav-text">检查协议一致性(Checking for Protocol Conformance)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E5%8D%8F%E8%AE%AE%E8%A6%81%E6%B1%82-x2F-x2F-todo"><span class="nav-number">1.19.14.</span> <span class="nav-text">可选的协议要求&#x2F;&#x2F;todo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95"><span class="nav-number">1.19.15.</span> <span class="nav-text">协议扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.19.15.1.</span> <span class="nav-text">提供默认实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95%E6%B7%BB%E5%8A%A0%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.19.15.2.</span> <span class="nav-text">为协议扩展添加限制条件</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">王帅帅</p>
  <div class="site-description" itemprop="description">写点有意思的东西</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王帅帅</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
