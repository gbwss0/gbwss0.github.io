<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Gbwss" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Gbwss">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Gbwss">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Wang shushu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Gbwss</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gbwss</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/27/Rust-%E6%89%80%E6%9C%89%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/Rust-%E6%89%80%E6%9C%89%E6%9D%83/" class="post-title-link" itemprop="url">Rust-所有权</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-27 09:41:00" itemprop="dateCreated datePublished" datetime="2022-08-27T09:41:00+08:00">2022-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:10:24" itemprop="dateModified" datetime="2022-10-15T10:10:24+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>所有权是Rust特有的核心概念，该特性让Rust即使没有垃圾回收或引用计数等机制也能够编写出内存安全的程序。</p>
<!---more--->

<ul>
<li><p><strong>野指针</strong>：是指向“垃圾”内存（不可用内存）的指针,指针创建时未初始化。指针变量刚被创建时不会自动成为NULL指针，它会随机指向一个内存地址。</p>
</li>
<li><p><strong>悬垂指针(Dangling pointers)</strong>: 指向无效数据的指针（当我们了解数据在内存中如何存储之后，这个就很有意义）。你可以在这里了解更多悬垂指针</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer"><strong>胖指针(fat pointer)</strong></a>：术语“胖指针”用于指代*动态大小类型*（DST）的引用和原始指针——切片或特征对象(<strong>The term “fat pointer” is used to refer to references and raw pointers to *dynamically sized types* (DSTs) – slices or trait objects.</strong>)</p>
</li>
</ul>
<h2 id="内存的堆和栈"><a href="#内存的堆和栈" class="headerlink" title="内存的堆和栈"></a>内存的堆和栈</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">str</span> = <span class="string">&quot;hello world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure>

<p>“hello world” 作为一个字符串常量（string literal），在编译时被存入可执行文件的 .RODATA 段（GCC）或者 .RDATA 段（VC++），然后在程序加载时，获得一个固定的内存地址。</p>
<p>这个时候如果没有后面的<code>to_string()</code>方法，那么 str 便是一个存在栈区的指针指向作为可执行文件的一部分存储在<strong>只读内存中的预分配文本(preallocated text)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            s: &amp;str</span><br><span class="line">            [–––––––––––]</span><br><span class="line">            +–––+–––+</span><br><span class="line">stack frame │ • │ 6 │ </span><br><span class="line">            +–│–+–––+</span><br><span class="line">              │                 </span><br><span class="line">              +––+                </span><br><span class="line">                 │</span><br><span class="line"> preallocated  +–V–+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line"> read-only     │ H │ e │ l │ l │ o │   │ w | o | r | l | d |</span><br><span class="line"> memory        +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br></pre></td></tr></table></figure>

<p>当执行 “hello world”.to_string() 时，在堆上，一块新的内存被分配出来，并把 “hello world” 逐个字节拷贝过去。</p>
<p><img src="https://static001.geekbang.org/resource/image/a7/4c/a7e7f2334460f15f9afd04ebd710b54c.jpg?wh=2312x2043" alt="img"></p>
<p>对于存入栈上的值，它的大小在编译期就需要确定。栈上存储的变量生命周期在当前调用栈的作用域内，无法跨调用栈引用。</p>
<p>堆可以存入大小未知或者动态伸缩的数据类型。堆上存储的变量，其生命周期从分配后开始，一直到释放时才结束，因此堆上的变量允许在多个调用栈之间引用。</p>
<p>但也导致堆变量的管理非常复杂，手工管理会引发很多内存安全性问题，而自动管理，无论是 GC 还是 ARC，都有性能损耗和其它问题。</p>
<p>一句话对比总结就是：栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。</p>
<h2 id="变量在被函数调用时发生了什么"><a href="#变量在被函数调用时发生了什么" class="headerlink" title="变量在被函数调用时发生了什么"></a>变量在被函数调用时发生了什么</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">42</span>, <span class="number">9</span>, <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(pos) = <span class="title function_ invoke__">find_pos</span>(data, v) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Found &#123;&#125; at &#123;&#125;&quot;</span>, v, pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">find_pos</span>(data: <span class="type">Vec</span>&lt;<span class="type">u32</span>&gt;, v: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (pos, item) <span class="keyword">in</span> data.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> *item == v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>(pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态数组因为大小在编译期无法确定，所以放在堆上，并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存。</p>
<p><img src="https://static001.geekbang.org/resource/image/f0/2f/f0989fa8611db83b79500060e8cd682f.jpg?wh=2312x2043" alt="img"></p>
<p>对于堆内存多次引用的问题，我们先来看大多数语言的方案：</p>
<ul>
<li>C&#x2F;C++ 要求开发者手工处理，非常不便。这需要我们在写代码时高度自律，按照前人总结的最佳实践来操作。但人必然会犯错，一个不慎就会导致内存安全问题，要么内存泄露，要么使用已释放内存，导致程序崩溃。</li>
<li>Java 等语言使用追踪式 GC，通过定期扫描堆上数据还有没有人引用，来替开发者管理堆内存，不失为一种解决之道，但 GC 带来的 STW 问题让语言的使用场景受限，性能损耗也不小。</li>
<li>ObjC&#x2F;Swift 使用自动引用计数（ARC），在编译时自动添加维护引用计数的代码，减轻开发者维护堆内存的负担。但同样地，它也会有不小的运行时性能损耗。</li>
</ul>
<h3 id="Rust-的解决思路"><a href="#Rust-的解决思路" class="headerlink" title="Rust 的解决思路"></a>Rust 的解决思路</h3><p>Rust 决定限制开发者随意引用的行为, 通过规则保证单一所有权：</p>
<ul>
<li>一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）</li>
<li>一个值同一时刻只能有一个所有者（There can only be one owner at a time）</li>
<li>当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped）</li>
</ul>
<p>所以上面的问题变成了这样：</p>
<p><img src="https://static001.geekbang.org/resource/image/fe/64/fe810cf1616bce15f53bcf6d28d7f864.jpg?wh=2312x2043" alt="img"></p>
<h2 id="Move-语义"><a href="#Move-语义" class="headerlink" title="Move 语义"></a>Move 语义</h2><p>上面的例子说明 赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</p>
<p>所以如果此时想在 main() 使用 data 则会报错，Rust 考虑到了这一点，提供了两种方案：</p>
<ol>
<li>如果你不希望值的所有权被转移，在 Move 语义外，Rust 提供了 Copy 语义。如果一个数据结构实现了 Copy trait，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）。</li>
<li>如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以“借用”数据，也就是 borrow</li>
</ol>
<h2 id="Copy-语义"><a href="#Copy-语义" class="headerlink" title="Copy 语义"></a>Copy 语义</h2><p>符合 Copy 语义的类型，在赋值或者传参时，值会自动按位拷贝(浅拷贝)。</p>
<p>也就是说，当需要移动一个值，如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行拷贝，否则使用 Move 语义进行移动。</p>
<h3 id="Copy-trait"><a href="#Copy-trait" class="headerlink" title="Copy trait"></a>Copy trait</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">fn is_copy&lt;T: Copy&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn types_impl_copy_trait() &#123;</span><br><span class="line">    is_copy::&lt;bool&gt;();</span><br><span class="line">    is_copy::&lt;char&gt;();</span><br><span class="line"></span><br><span class="line">    // all iXX and uXX, usize/isize, fXX implement Copy trait</span><br><span class="line">    is_copy::&lt;i8&gt;();</span><br><span class="line">    is_copy::&lt;u64&gt;();</span><br><span class="line">    is_copy::&lt;i64&gt;();</span><br><span class="line">    is_copy::&lt;usize&gt;();</span><br><span class="line"></span><br><span class="line">    // function (actually a pointer) is Copy</span><br><span class="line">    is_copy::&lt;fn()&gt;();</span><br><span class="line"></span><br><span class="line">    // raw pointer is Copy</span><br><span class="line">    is_copy::&lt;*const String&gt;();</span><br><span class="line">    is_copy::&lt;*mut String&gt;();</span><br><span class="line"></span><br><span class="line">    // immutable reference is Copy</span><br><span class="line">    is_copy::&lt;&amp;[Vec&lt;u8&gt;]&gt;();</span><br><span class="line">    is_copy::&lt;&amp;String&gt;();</span><br><span class="line"></span><br><span class="line">    // array/tuple with values which is Copy is Copy</span><br><span class="line">    is_copy::&lt;[u8; 4]&gt;();</span><br><span class="line">    is_copy::&lt;(&amp;str, &amp;str)&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn types_not_impl_copy_trait() &#123;</span><br><span class="line">    // unsized or dynamic sized type is not Copy</span><br><span class="line">    is_copy::&lt;str&gt;();</span><br><span class="line">    is_copy::&lt;[u8]&gt;();</span><br><span class="line">    is_copy::&lt;Vec&lt;u8&gt;&gt;();</span><br><span class="line">    is_copy::&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    // mutable reference is not Copy</span><br><span class="line">    is_copy::&lt;&amp;mut String&gt;();</span><br><span class="line"></span><br><span class="line">    // array / tuple with values that not Copy is not Copy</span><br><span class="line">    is_copy::&lt;[Vec&lt;u8&gt;; 4]&gt;();</span><br><span class="line">    is_copy::&lt;(String, u32)&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    types_impl_copy_trait();</span><br><span class="line">    types_not_impl_copy_trait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结一下：</p>
<ul>
<li>原生类型，包括函数、不可变引用和裸指针实现了 Copy；</li>
<li>数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；</li>
<li>可变引用没有实现 Copy；</li>
<li>非固定大小的数据结构，没有实现 Copy。</li>
</ul>
<h2 id="Borrow-语义"><a href="#Borrow-语义" class="headerlink" title="Borrow 语义"></a>Borrow 语义</h2><p>Borrow 语义允许一个值的所有权，在不发生转移的情况下，被其它上下文使用。就好像住酒店或者租房那样，旅客 &#x2F; 租客只有房间的临时使用权，但没有它的所有权(<strong>默认情况下，Rust 的借用都是只读的</strong>)。另外，Borrow 语义通过引用语法（&amp; 或者 &amp;mut）来实现。</p>
<h3 id="只读借用"><a href="#只读借用" class="headerlink" title="只读借用"></a>只读借用</h3><p>在其他语言中，函数传参有两种方式：值传递（pass-by-value）和引用传递（pass-by-reference）（提问）</p>
<p>但 Rust 没有传引用的概念，Rust 所有的参数传递都是传值，不管是 Copy 还是 Move。所以在 Rust 中，你必须<strong>显式</strong>地把某个数据的引用，传给另一个函数。（就是copy栈上的值，不论栈上存的是“指针&#x2F;地址”还是“值”。）</p>
<p>同时，<strong>Rust 的只读借用实现了 Copy trait，也就意味着引用的赋值、传参都会产生新的浅拷贝。</strong></p>
<p>（这里可以分析一下这段代码）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data1</span> = &amp;data;</span><br><span class="line">    <span class="comment">// 值的地址是什么？引用的地址又是什么？</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;addr of value: &#123;:p&#125;(&#123;:p&#125;), addr of data &#123;:p&#125;, data1: &#123;:p&#125;&quot;</span>,</span><br><span class="line">        &amp;data, data1, &amp;&amp;data, &amp;data1</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;sum of data1: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">sum</span>(data1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sum</span>(data: &amp;<span class="type">Vec</span>&lt;<span class="type">u32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="comment">// 值的地址会改变么？引用的地址会改变么？</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;addr of value: &#123;:p&#125;, addr of ref: &#123;:p&#125;&quot;</span>, data, &amp;data);</span><br><span class="line">    data.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">fold</span>(<span class="number">0</span>, |acc, x| acc + x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://static001.geekbang.org/resource/image/44/39/441678ea9318e9f159cac6b274aef239.jpg?wh=2312x2043" alt="img"></p>
<p>虽然 data 有很多只读引用指向它，但堆上的数据依旧只有 data 一个所有者，<strong>所以值的任意多个引用并不会影响所有权的唯一性</strong>。但是这样不就又回到我们之前在想极力避免的使用已释放内存（use after free）这样的内存安全问题吗？所以，我们对借用也要有约束。</p>
<h3 id="借用的生命周期及其约束"><a href="#借用的生命周期及其约束" class="headerlink" title="借用的生命周期及其约束"></a>借用的生命周期及其约束</h3><p><strong>借用不能超过（outlive）值的生存期</strong></p>
<p>在上面的代码中，sum() 函数处在 main() 函数下一层调用栈中，它结束之后 main() 函数还会继续执行，所以在 main() 函数中定义的 data 生命周期要比 sum() 中对 data 的引用要长，这样不会有任何问题。</p>
<p>但如果是这样的代码呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">local_ref</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;:p&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">local_ref</span>&lt;<span class="symbol">&#x27;a</span>&gt;() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">42</span>;</span><br><span class="line">    &amp;a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，生命周期更长的 main() 函数变量 r ，引用了生命周期更短的 local_ref() 函数里的局部变量，这违背了有关引用的约束，所以 Rust 不允许这样的代码编译通过。</p>
<p>那么，如果我们在堆内存中，使用栈内存的引用，可以么？根据过去的开发经验，你也许会脱口而出：不行！因为堆内存的生命周期显然比栈内存要更长更灵活，这样做内存不安全。</p>
<p>我们写段代码试试看，把一个本地变量的引用存入一个可变数组中。从基础知识的学习中我们知道，可变数组存放在堆上，栈上只有一个胖指针指向它，所以这是一个典型的把栈上变量的引用存在堆上的例子（情况 2）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">data</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">u32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="title function_ invoke__">push_local_ref</span>(&amp;<span class="keyword">mut</span> data);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;data: &#123;:?&#125;&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">push_local_ref</span>(data: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;&amp;<span class="type">u32</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">42</span>;</span><br><span class="line">    data.<span class="title function_ invoke__">push</span>(&amp;v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里，你是不是有点迷糊了，这三种情况，为什么同样是对栈内存的引用，怎么编译结果都不一样？</p>
<p>这三段代码看似错综复杂，但如果抓住了一个核心要素“<strong>在一个作用域下，同一时刻，一个值只能有一个所有者</strong>”，你会发现，其实很简单。</p>
<p>堆变量的生命周期不具备任意长短的灵活性，因为堆上内存的生死存亡，跟栈上的所有者牢牢绑定。而栈上内存的生命周期，又跟栈的生命周期相关，所以我们<strong>核心只需要关心调用栈的生命周期。</strong></p>
<h2 id="拓展–-String-vs-amp-str-in-Rust"><a href="#拓展–-String-vs-amp-str-in-Rust" class="headerlink" title="拓展– String vs &amp;str in Rust"></a>拓展– String vs &amp;str in Rust</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>;</span><br><span class="line">  <span class="title function_ invoke__">greet</span>(my_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_name</span> = <span class="string">&quot;Pascal&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">my_name.<span class="title function_ invoke__">push_str</span>( <span class="string">&quot; Precht&quot;</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut my_name = &quot;Pascal&quot;.to_string();</span><br><span class="line">my_name.push_str( &quot; Precht&quot;);</span><br><span class="line"></span><br><span class="line">let last_name = &amp;my_name[7..];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            my_name: String   last_name: &amp;str</span><br><span class="line">            [––––––––––––]    [–––––––]</span><br><span class="line">            +–––+––––+––––+–––+–––+–––+</span><br><span class="line">stack frame │ • │ 16 │ 13 │   │ • │ 6 │ </span><br><span class="line">            +–│–+––––+––––+–––+–│–+–––+</span><br><span class="line">              │                 │</span><br><span class="line">              │                 +–––––––––+</span><br><span class="line">              │                           │</span><br><span class="line">              │                           │</span><br><span class="line">              │                         [–│––––––– str –––––––––]</span><br><span class="line">            +–V–+–––+–––+–––+–––+–––+–––+–V–+–––+–––+–––+–––+–––+–––+–––+–––+</span><br><span class="line">       heap │ P │ a │ s │ c │ a │ l │   │ P │ r │ e │ c │ h │ t │   │   │   │</span><br><span class="line">            +–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+–––+</span><br></pre></td></tr></table></figure>



<p><code>String</code> is the dynamic heap string type, like <code>Vec</code>: use it when you need to own or modify your string data.</p>
<p><code>str</code> is an immutable1 sequence of UTF-8 bytes of dynamic length somewhere in memory. Since the size is unknown, one can only handle it behind a pointer. This means that <code>str</code> most commonly2 appears as <code>&amp;str</code>: a reference to some UTF-8 data, normally called a “string slice” or just a “slice”. <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch04-03-slices.html">A slice</a> is just a view onto some data, and that data can be anywhere, e.g.</p>
<ul>
<li><p><strong>In static storage</strong>: a string literal <code>&quot;foo&quot;</code> is a <code>&amp;&#39;static str</code>. The data is hardcoded into the executable and loaded into memory when the program runs.</p>
</li>
<li><p><strong>Inside a heap allocated <code>String</code></strong>: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/string/struct.String.html#deref"><code>String</code> dereferences to a <code>&amp;str</code> view</a> of the <code>String</code>‘s data.</p>
</li>
<li><p><strong>On the stack</strong>: e.g. the following creates a stack-allocated byte array, and then gets a <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/str/fn.from_utf8.html">view of that data as a <code>&amp;str</code></a>:</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: &amp;[<span class="type">u8</span>] = &amp;[<span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="string">b&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">stack_str</span>: &amp;<span class="type">str</span> = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(x).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h2><p>正如在<strong>Memory safety in Rust - part 2</strong>[1]所展示的，把一个变量赋值给另一个变量会把所有权(ownership)转移给受让者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let v:Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">let v1 = v;//v1 is the new owner</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>v</code>被move到<code>v1</code>。但是move <code>v</code>意味着什么？要想理解这个问题，我们需要先来看一下一个<code>Vec</code>在内存中是如何布局的：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gRo2fL9GmTDZEUo7w3kRSW5KicTkpV2MBDfeZI6bqVOOZNnJ9potyDmw5HiaU5iauGOMmbJ2OicgsOiaHEMDU6AemDQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>Vec</code>不得不维护一个动态增长或收缩(shrinking)的缓冲区(buffer)。这个缓冲区被分配在堆上，包含<code>Vec</code>里真正的元素。此外，<code>Vec</code>还在栈上有一个小的对象。这个对象包含某些内务信息：一个指向堆上缓冲区的<em>指针(pointer)</em> ，缓存区的<em>容量(capacity)</em> 和<em>长度(length)</em> (比如，当前被填满的容量是多少)。</p>
<p>当变量<code>v</code>被move到<code>v1</code>时，栈上的对象被逐位拷贝(bitwise copy)：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gRo2fL9GmTDZEUo7w3kRSW5KicTkpV2MBNdGEh0EQVeCUgN44WC8RbtBVw5YCFZnWw9pDKajZ2ZevdllicADympw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<blockquote>
<p>“</p>
<p>在前面的例子中，本质上发生的是一个浅拷贝(shallow copy)。这与C++形成了鲜明的对比，当一个向量被赋值给另一个变量时，C++会进行深拷贝(deep copy)。</p>
</blockquote>
<p>堆上的缓冲区保持不变。这确实是一个move：现在<code>v1</code>负责释放缓冲区，<code>v</code>不能接触这个缓冲区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v: Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">let v1 = v;</span><br><span class="line">println!(&quot;v&#x27;s length is &#123;&#125;&quot;, v.len());//error: borrow of moved value: `v`</span><br></pre></td></tr></table></figure>

<p>这个所有权的改变很好，因为如果<code>v</code>和<code>v1</code>都被允许访问，那么就有两个栈上的对象指向相同的堆缓冲区。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gRo2fL9GmTDZEUo7w3kRSW5KicTkpV2MBkNFntq3ItpUQzLk3Gjh0gWB137t6GzpyDH44x19cv8CGRlU1NOkqNA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">这种情况，应该由哪个对象释放缓冲区呢？因为这是不清晰的，所以Rust从根本上避免了这种情况的出现。</p>
<p>赋值不是唯一涉及到move的操作。当传递参数或者从函数返回的时候，值也会被move：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">//v is first moved into print_len&#x27;s v1</span></span><br><span class="line"><span class="comment">//and then moved into v2 when print_len returns it</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v2</span> = <span class="title function_ invoke__">print_len</span>(v);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_len</span>(v1: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;v1&#x27;s length is &#123;&#125;&quot;</span>, v1.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    v1<span class="comment">//v1 is moved out of the function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者被赋值给结构体或枚举的成员:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Numbers</span> &#123;</span><br><span class="line">    nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">//v moved into nums field of the Numbers struct</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">n</span> = Numbers &#123; nums: v &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">NothingOrString</span> &#123;</span><br><span class="line">    Nothing,</span><br><span class="line">    <span class="title function_ invoke__">Str</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&quot;I am moving soon&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="comment">//s moved into the enum</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">nos</span> = NothingOrString::<span class="title function_ invoke__">Str</span>(s);</span><br></pre></td></tr></table></figure>

<p>以上就是关于move的全部内容。下面让我们来看一下copy。</p>
<h2 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h2><p>还记得上面的这个例子么？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = v;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v&#x27;s length is &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">len</span>());<span class="comment">//error: borrow of moved value: `v`</span></span><br></pre></td></tr></table></figure>

<p>如果我们把变量<code>v</code>和<code>v1</code>的类型从<code>Vec</code>改为<code>i32</code>会发生什么？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">i32</span> = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = v;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v is &#123;&#125;&quot;</span>, v);<span class="comment">//compiles fine, no error!</span></span><br></pre></td></tr></table></figure>

<p>这几乎是相同的代码。为什么这次赋值没有把<code>v</code> move到<code>v1</code>呢？要想理解这个，我们需要再来看一下内存布局:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gRo2fL9GmTDZEUo7w3kRSW5KicTkpV2MBq5EvEMX6Al3RsViamh9icOBD42bAB8B5209RibZCb5Wzibj1UgacwJb2eg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>在这个例子中，值完全被包含在栈上。在堆上什么都没有拥有。这就是为什么<code>v</code>和<code>v1</code>都被允许访问是没有问题的——它们是完全独立的拷贝(copy)。</p>
<p>像这样没有拥有其他资源的类型且可以被逐位拷贝(bitwise copy)的类型被称为<code>Copy</code>类型。它们实现了<strong>Copy marker trait</strong>[2]。所有的基本类型，像整数，浮点数和字符都是<code>Copy</code>类型。结构体或枚举默认不是<code>Copy</code>但是你可以派生(derive)自一个<code>Copy</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SignedOrUnsignedInt</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Signed</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Unsigned</span>(<span class="type">u32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“</p>
<p>在派生语句中的<code>Clone</code>是需要的，因为<code>Copy</code>的定义类似这样:<code>pub trait Copy:Clone &#123;&#125;</code></p>
</blockquote>
<p>为了能让<code>#[derive(Copy, Clone)]</code>正常工作，结构体或枚举的所有成员自身必须是<code>Copy</code>类型。例如，下面这样就无法正常工作:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//error:the trait `Copy` may not be implemented for this type</span></span><br><span class="line"><span class="comment">//because its nums field does not implement `Copy`</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Numbers</span> &#123;</span><br><span class="line">    nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你也可以手动实现<code>Copy</code>和<code>Clone</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//no method in Copy because it is a marker trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Copy</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Clone</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来讲，任何实现了<code>Drop</code>的类型都不能被<code>Copy</code>，因为<code>Drop</code>是被拥有其他资源的类型来实现的，且因此不能被简单地逐位拷贝。但是<code>Copy</code>类型应该是可以被拷贝的。因此，<code>Drop</code>和<code>Copy</code>不能很好地混合在一起使用。</p>
<p>以上就是关于copy的内容，下面是clone。</p>
<h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h2><p>当一个值被move的时候，Rust做一个浅拷贝；但是如果你想像在C++里那样创建一个深拷贝该怎么办呢？要实现这个，这个类型必须首先实现<strong>Clone trait</strong>[3]。接着做一个深拷贝，客户端代码应该调用<code>clone</code>方法:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = v.<span class="title function_ invoke__">clone</span>();<span class="comment">//ok since Vec implements Clone</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;v&#x27;s length is &#123;&#125;&quot;</span>, v.<span class="title function_ invoke__">len</span>());<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<p>在<code>clone</code>调用后，就产生了下面的内存布局:</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gRo2fL9GmTDZEUo7w3kRSW5KicTkpV2MBSjpQrFJibXXMzCbIiaUVwJZ4jNbTajfiaxicx0ykR3aA7UVQG3dr8a1xyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">由于是深拷贝，<code>v</code>和<code>v1</code>可以自由独立地释放它们的堆缓冲区。</p>
<p>Clone方法不总是会创建一个深拷贝。类型可以以任意想要的方式自由实现<code>clone</code>，但是语义上，它应该足够接近复制一个对象的含义。例如，<code>Rc</code>和<code>Arc</code>取而代之的是增加了一个引用计数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/11/iOS-NavigationBar%E7%9A%84backgroundColor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/11/iOS-NavigationBar%E7%9A%84backgroundColor/" class="post-title-link" itemprop="url">iOS-NavigationBar的backgroundColor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-11 09:41:00" itemprop="dateCreated datePublished" datetime="2022-07-11T09:41:00+08:00">2022-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:15:57" itemprop="dateModified" datetime="2022-10-15T10:15:57+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在代码中发现设置navigationBar的背景颜色都是将一个颜色绘制为 UIImage 然后 通过 <code>setBackgroundImage()</code>进行赋值，而没有使用常见的 backgroundColor。</p>
<!---more--->

<p>尝试直接给 navigationBar 直接设置 backgroundColor 发现并没有正常工作，只有在 UINavigationBarAppearance().backgroundColor 上赋值才会有用，所以查找资料了解了一下navigationBar的背景颜色</p>
<h2 id="backgroundColor"><a href="#backgroundColor" class="headerlink" title="backgroundColor"></a>backgroundColor</h2><p>直接添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">backgroundColor = .green</span><br></pre></td></tr></table></figure>

<p>会被 navigationBar 的  <code>isTranslucent</code>  属性所影响： </p>
<p> isTranslucent &#x3D; false</p>
<img src="/Users/yuhan.wang/Downloads/IMG_C56A633B2AED-1.jpeg" alt="IMG_C56A633B2AED-1" style="zoom:67%;" />

<p>isTranslucent &#x3D; true</p>
<img src="/Users/yuhan.wang/Downloads/IMG_0123.jpg" alt="IMG_0123" style="zoom:67%;" />

<p>也就是说 他是真正的背景颜色 navigationBar的颜色设置不来源于继承自UIView的 backgroundColor </p>
<p>附：在iOS15中 navigationBar 默认为全透明 所以此时的表现是这样：</p>
<img src="/Users/yuhan.wang/Downloads/IMG_532CFEA85A81-1.jpeg" alt="IMG_532CFEA85A81-1" style="zoom: 33%;" />

<h2 id="barTintColor"><a href="#barTintColor" class="headerlink" title="barTintColor"></a>barTintColor</h2><p> barTintColor 才是真正设置 navigationBar 的 backgroundColor 的方法但是直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barTintColor = .orange</span><br></pre></td></tr></table></figure>

<p>的颜色并不是真正的  .orange 上面蒙了一层白色</p>
<p><img src="/Users/yuhan.wang/Downloads/IMG_0125.jpg" alt="IMG_0125"></p>
<p>查找官方文档后发现 <code>isTranslucent</code>属性默认为true 那如果将 isTranslucent 设为 false呢</p>
<p><img src="/Users/yuhan.wang/Downloads/IMG_0126.jpg" alt="IMG_0126"></p>
<p>附：tintColor是应用于导航项和按钮项的色调颜色</p>
<img src="https://docs-assets.developer.apple.com/published/dde7452123/e8608c12-1a29-47c9-95c5-984a0ca17bce.png" alt="A navigation bar diagram that depicts the fonts, color, and layout of a navigation bar, including the tint color, title text atributes, bar tint color, and the title vertical position." style="zoom:67%;" />



<p>那我们如果既想使用半透明 又想要纯正的颜色呢 那就需要设置backgroundImage了：</p>
<h2 id="backgroundImage"><a href="#backgroundImage" class="headerlink" title="backgroundImage"></a>backgroundImage</h2><p>直接设置 backgroundImage 即可得到我们想要的效果（imge()为给UIColor添加的extension)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setBackgroundImage(UIColor.yellow.image(), for: .default)</span><br></pre></td></tr></table></figure>

<p><img src="/Users/yuhan.wang/Downloads/IMG_0127.jpg" alt="IMG_0127"></p>
<p>但是如果我们设置一个半透明图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setBackgroundImage(UIColor.yellow.withAlphaComponent(0.5).image(), for: .default)</span><br></pre></td></tr></table></figure>

<p>则出现了和之前一样的问题 translucent 为 true 时 影响到了原来的布局。</p>
<p><img src="/Users/yuhan.wang/Downloads/IMG_0CA250DF94E3-1.jpeg" alt="IMG_0CA250DF94E3-1"></p>
<h4 id="translucent-和-setBackgroundImage"><a href="#translucent-和-setBackgroundImage" class="headerlink" title="translucent 和 setBackgroundImage"></a>translucent 和 setBackgroundImage</h4><p>前面提到我们可以通过修改背景图片来修改导航栏的背景色，设置了背景图片后在有些页面我们会遇到一些奇怪的问题，发现原来布局正常的页面显示不对了，会多出一部分空白或者被导航栏遮挡住了。</p>
<p>通过打印出 translucent 的值我们发现设置了纯色的背景图后原来半透明的导航栏变成了不透明的，结合前面提到的 translucent 对布局起点的影响，如果页面是按照半透明情况，即 rootView 从（0，0）开始布局来设置子视图的 frame，那么设置了纯色背景图后 translucent 变成了 false，此时 rootview 从 navigationBar 下面开始布局 。为什么设置背景图片会影响 translucent 呢，通过查看文档发现了如下说明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> New behavior on iOS 7.</span></span><br><span class="line"><span class="comment"> Default is YES.</span></span><br><span class="line"><span class="comment"> You may force an opaque background by setting the property to NO.</span></span><br><span class="line"><span class="comment"> If the navigation bar has a custom background image, the default is inferred </span></span><br><span class="line"><span class="comment"> from the alpha values of the image—YES if it has any pixel with alpha &lt; 1.0</span></span><br><span class="line"><span class="comment"> If you send setTranslucent:YES to a bar with an opaque custom background image</span></span><br><span class="line"><span class="comment"> it will apply a system opacity less than 1.0 to the image.</span></span><br><span class="line"><span class="comment"> If you send setTranslucent:NO to a bar with a translucent custom background image</span></span><br><span class="line"><span class="comment"> it will provide an opaque background for the image using the bar&#x27;s barTintColor if defined, or black</span></span><br><span class="line"><span class="comment"> for UIBarStyleBlack or white for UIBarStyleDefault if barTintColor is nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>,<span class="keyword">getter</span>=isTranslucent) <span class="type">BOOL</span> translucent <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">3</span>_0) <span class="built_in">UI_APPEARANCE_SELECTOR</span>; <span class="comment">// Default is NO on iOS 6 and earlier. Always YES if barStyle is set to UIBarStyleBlackTranslucent</span></span><br></pre></td></tr></table></figure>

<p>也就是说背景图片如果包含 alpha 的色值，系统会默认将 translucent 设置为 true，没有包含 alpha 色值会将 translucent 设置为 false。这下真相大白了，原来我们前面设置了纯绿色的背景图片，是不包含 alpha 色值的，即系统默认将 translucent 设置成了 false。但这是针对没有手动设置 translucent 值的情况，<strong>如果我们手动设置了 translucent，那么系统就不会根据背景图片的 alpha 来修改 translucent</strong>。</p>
<p>至此，我们了解了苹果是如何使用这几个属性的：</p>
<ol>
<li>translucent 默认为 true，rootView 从（0，0）开始布局</li>
<li>translucent 设置为 false，rootView 从导航栏底部开始布局</li>
<li>automaticallyAdjustsScrollViewInsets 默认值是 true，用来纠正scrollview在全屏模式下的显示；</li>
<li>设置 <code>UINavigationBar</code> 的背景图片可以改变导航栏背景色，如果背景图片包含 alpha 的色值，系统会默认将 translucent 设置为 true，没有包含 alpha 色值会将 translucent 设置为 false。但这是针对没有手动设置 translucent 值的情况，<strong>如果我们手动设置了 translucent，那么系统就不会根据背景图片的 alpha 来修改 translucent</strong>。</li>
</ol>
<hr>
<p>上面是在iOS13以前的 Legacy Customizations 在 iOS13 苹果提出了新的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbarappearance"><code>UINavigationBarAppearance</code></a>来配置navigationBar的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/3198028-standardappearance"><code>standardAppearance</code></a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/3198026-compactappearance"><code>compactAppearance</code></a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/3198027-scrolledgeappearance"><code>scrollEdgeAppearance</code></a> 三种状态。</p>
<p>UINavigationBarAppearance 继承自 UIBarAppearance ，在这里我们可以自由的定义backgroundColor 等等各种属性。</p>
<p>苹果官网的介绍：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar">https://developer.apple.com/documentation/uikit/uinavigationbar</a></p>
<blockquote>
<h3 id="Customize-the-Appearance-of-a-Navigation-Bar"><a href="#Customize-the-Appearance-of-a-Navigation-Bar" class="headerlink" title="Customize the Appearance of a Navigation Bar"></a>Customize the Appearance of a Navigation Bar</h3><p>Navigation bars have two standard appearance styles: white with dark text or black with light text. Use the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624955-barstyle"><code>barStyle</code></a> property to select the style. Any changes you make to other navigation bar appearance properties override those inferred from the bar style.</p>
<p>Navigation bars are translucent by default; that is, their background color is semitransparent. You can make the navigation bar opaque by setting the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624928-istranslucent"><code>isTranslucent</code></a> property to <code>false</code>.</p>
<p>You can specify a custom tint color for a navigation bar background using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624931-bartintcolor"><code>barTintColor</code></a> property. Setting this property overrides the default color inferred from the bar style. As with all <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview"><code>UIView</code></a> subclasses, you can control the color of the interactive elements within navigation bars, including button images and titles, using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/1622467-tintcolor"><code>tintColor</code></a> property.</p>
<p>The <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624953-titletextattributes"><code>titleTextAttributes</code></a> property specifies the attributes for displaying the bar’s title text. You can specify the font, text color, text shadow color, and text shadow offset for the title in the text attributes dictionary using the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsattributedstring/key/1528839-font"><code>font</code></a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsattributedstring/key/1533563-foregroundcolor"><code>foregroundColor</code></a>, and <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsattributedstring/key/1524321-shadow"><code>shadow</code></a> keys, respectively. For more information about string-formatting attributes, see <code>Character Attributes</code>.</p>
<p>Use the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624959-settitleverticalpositionadjustme"><code>setTitleVerticalPositionAdjustment(_:for:)</code></a> method to adjust the vertical position of the title. This method allows you to specify the adjustment dependent on the bar height, which is represented by the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uibarmetrics"><code>UIBarMetrics</code></a> enum. The following figure shows a navigation bar with custom tint color, title text attributes, and bar tint color.</p>
<img src="https://docs-assets.developer.apple.com/published/dde7452123/e8608c12-1a29-47c9-95c5-984a0ca17bce.png" alt="A navigation bar diagram that depicts the fonts, color, and layout of a navigation bar, including the tint color, title text atributes, bar tint color, and the title vertical position." style="zoom:67%;" />

<p>To allow complete customization over the appearance of navigation bars, you can additionally provide custom background and shadow images. To provide a custom background image, use the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624968-setbackgroundimage"><code>setBackgroundImage(_:for:barMetrics:)</code></a> method, providing a <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiimage"><code>UIImage</code></a> object for the appropriate bar position and metrics values. Use a <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uibarposition"><code>UIBarPosition</code></a> value for the bar position argument to specify whether to use the supplied image at the bottom or the top of the window, and if it appears at the top, whether to extend it upward under the status bar. Similarly, you can specify that the image should be used for either compact or default bar metrics, with or without a prompt, by providing a <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uibarmetrics"><code>UIBarMetrics</code></a> value to the bar metrics argument.</p>
<p>To add a shadow, provide a resizable <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiimage"><code>UIImage</code></a> to the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624963-shadowimage"><code>shadowImage</code></a> property. To use the custom shadow image, you need to have specified a custom background image. The following figure shows a navigation bar with a custom background image, supplied using <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624968-setbackgroundimage"><code>setBackgroundImage(_:for:barMetrics:)</code></a> with a bar position value of <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uibarposition/topattached"><code>UIBarPosition.topAttached</code></a> and a bar metrics value of <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uibarmetrics/default"><code>UIBarMetrics.default</code></a>. A custom image has also been provided to the <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationbar/1624963-shadowimage"><code>shadowImage</code></a> property.</p>
<img src="https://docs-assets.developer.apple.com/published/dde7452123/01969d1a-db6b-4ef5-b86b-45ffa1730b85.png" alt="A screenshot of a navigation bar with the location of a background image and a shadow image labeled." style="zoom:67%;" />

<p>To see examples of customizing a navigation bar, see <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uinavigationcontroller/customizing_your_app_s_navigation_bar">Customizing Your App’s Navigation Bar</a>.</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/19/Git%20%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/19/Git%20%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Git原理初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-19 09:41:00" itemprop="dateCreated datePublished" datetime="2022-05-19T09:41:00+08:00">2022-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:14:26" itemprop="dateModified" datetime="2022-10-15T10:14:26+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>为什么每次在提交前都需要添加到暂存区呢？ </p>
<p>如果有一百个相同的文件是会存储一百次吗？</p>
<p>本文将从Git的底层存储结构初窥Git的底层工作原理</p>
<!---more--->

<h2 id="Git保存版本的机制"><a href="#Git保存版本的机制" class="headerlink" title="Git保存版本的机制"></a>Git保存版本的机制</h2><p>1、集中式版本控制工具(如SVN)的文件管理机制：以文件变更列表的方式存储信息。</p>
<p>这类系统将它们保存的信息看作是一组基本文件(对应下图的Version1)和每个文件随时间逐步累积的差异(对应下图的其他Version)，在文件管理的时候只保存当前版本相对于上一个版本的差异，这是一种增量式的版本控制。<br><img src="https://img-blog.csdnimg.cn/20181127103822990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YnVsYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>2、Git 的文件管理机制：Git 把数据看作是小型文件系统的一组快照</p>
<p>每次提交更新时 Git 都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。</p>
<p>所以 Git 的工作方式可以称之为快照流。（这样的话就不用像集中式的 要一次次回退 才会去到历史版本 Git只需要切换到对应的版本指向的内容即可）</p>
<p>下图中Version2及其之后的实线框中的文件表示该版本的该文件相较于上个版本有变动，虚线框中的文件表示该版本的该文件相较于上一版本没有变动(只保存上一个版本的指针，而无需保存文件)，这样根据当前版本的文件和指向上一版本的指针就可以找到该版本的所有文件的状态</p>
<p><img src="https://img-blog.csdnimg.cn/20181127104355432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3J1YnVsYWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以看出 git的版本控制依赖的是每一次的commit 那怎么区分每次commit呢 就依靠每次提交都会生成一个独一无二的commitID</p>
<p>那么如何保证每次的 commitID 都是独一无二的呢？ Git 使用了Hash算法来进行保证和文件验证</p>
<h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点：</p>
<ol>
<li><p>不管输入数据的数据量有多大，使用同一个哈希算法，得到的加密结果长度固定</p>
</li>
<li><p>哈希算法确定，输入数据确定，输出结果保证不变</p>
</li>
<li><p>哈希算法确定，输入数据有变化，输出结果一定有变化</p>
</li>
</ol>
<p>哈希算法有很多种，如：MD5、SHA-1等。Git 底层采用的是 SHA-1 ，因为哈希算法可以被用来验证文件，Git 就是靠这种机制来从根本上保证数据完整性的</p>
<h1 id="Git的实现原理"><a href="#Git的实现原理" class="headerlink" title="Git的实现原理"></a>Git的实现原理</h1><p>Git很好的解决了版本状态记录的问题，在此基础上实现了版本切换、差异比较、分支管理、分布式协作等等炫酷功能。那我们就一起通过实验看看Git数据库是如何工作的</p>
<p>这里我们会利用到下面几个命令：</p>
<ul>
<li><strong>git init</strong>   用于创建一个空的git仓库，或重置一个已存在的git仓库</li>
<li><strong>git cat-file</strong>   git底层命令，用于查看Git数据库中数据 （-t 查看类型 -p 查看内容）</li>
<li><strong>watch</strong>  可以将命令的输出结果输出到标准输出设备,多用于周期性执行命令&#x2F;定时执行（这里我们结合tree 实时观察文件结构变化）</li>
</ul>
<h2 id="开始探索！"><a href="#开始探索！" class="headerlink" title="开始探索！"></a>开始探索！</h2><p>首先我们初始化一个仓库 并使用watch命令配合tree观察 .git文件</p>
<p><code> watch -n .5 tree .git</code></p>
<p>观察objects文件夹，这就是git数据库的<strong>存储位置</strong>。</p>
<p>然后新建文件<br>git add</p>
<p>观察 blob 文件</p>
<p>git commit</p>
<p>观察tree  - 100个相同文件</p>
<p>观察commit 内容信息</p>
<p>commit对象能够帮你记录什么时间，由什么人，因为什么原因提交了一个新的版本，这个新的版本的父版本又是谁。</p>
<p>我们可以很清楚的看到，一个提交对象包含着所提交版本的树对象hash键值，author和commiter，以及修改和提交的时间，最后是本次提交的注释。</p>
<p>然后再新增文件 git commit </p>
<p>git log 观察commit文件</p>
<p>至此 我们就基本了解了树对象（tree object）和 提交对象（commit object）</p>
<p>利用树对象（tree object）解决文件名保存和文件组织问题</p>
<p>利用提交对象（commit object）记录版本间的时序关系和版本注释</p>
<p>看ppt 回顾一下上面的内容</p>
<p>commit保存的快照是什么呢</p>
<p>保存的是两个指针 一个指向上次的commit对象 另一个指向当前的这个tree</p>
<p>其实抽象的来看 这个快照就是保存了当前版本的所有文件 更准确的说是所有文件的引用</p>
<p>这也是我们可以迅速在各个版本间迭代的原因</p>
<p>一百个文件 上面也解释了 git只关注文件内容 那么也就只会有一个blob文件。</p>
<p>所以呢：</p>
<p>每次我们运行 git add 和 git commit 命令时， </p>
<p>Git 所做的实质工作是将被改写的文件保存为数据对象，更新暂存区，记录树对象，最后创建一个指明了顶层树对象和父提交的提交对象。 这三种主要的 Git 对象——数据对象、树对象、提交对象——最初均以单独文件的形式保存在 .git&#x2F;objects 目录下。</p>
<p>但是到这里，我们对版本和数据对象的操作都是基于hash键值的，这些毫无直观含义的字符串让人很头疼，不会有人愿意一直急着最新提交对应的hash键值的。</p>
<p>那git是如何进行分支管理的呢</p>
<hr>
<p>看ppt第一页</p>
<p>开始演示</p>
<p>git log</p>
<p>cat .git&#x2F;refs&#x2F;heads&#x2F;master</p>
<p>Git checkout -b dev</p>
<p>再cat一下</p>
<p>再新建一个文件</p>
<p>git add</p>
<p>git commit -m</p>
<p>再cat一下前面那两个dev 和 master 发现是不一样的</p>
<p>对了 如果好奇head的话 可以cat一下</p>
<p>git log –oneline –graph</p>
<p>再看看tree</p>
<p>再看看ppt</p>
<hr>
<p>merge啦</p>
<p>git switch master</p>
<p>git merge dev</p>
<h2 id="Git的引用（references）与分支"><a href="#Git的引用（references）与分支" class="headerlink" title="Git的引用（references）与分支"></a>Git的引用（references）与分支</h2><p>Git的引用（references）保存在.git&#x2F;refs目录下。git的引用类似于一个指针，它指向的是某一个hash键值。<br>Git 分支的本质：一个指向某一系列提交之首的指针或引用。</p>
<h1 id="Git基本原理总结"><a href="#Git基本原理总结" class="headerlink" title="Git基本原理总结"></a><strong>Git基本原理总结</strong></h1><p>Git的核心是它的对象数据库，其中保存着git的对象，其中最重要的是<strong>blob</strong>、<strong>tree</strong>和<strong>commit</strong>对象。</p>
<p>blob对象实现了对文件内容的记录，tree对象实现了对文件名、文件目录结构的记录，commit对象实现了对版本提交时间、版本作者、版本序列、版本说明等附加信息的记录。</p>
<p>这三类对象，完美实现了git的基础功能：对版本状态的记录。</p>
<p> Git引用是指向git对象hash键值的类似指针的文件。</p>
<p>通过Git引用，我们可以更加方便的定位到某一版本的提交。Git的<strong>branch</strong>、<strong>tags</strong>等功能都是基于Git引用实现的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34342207/article/details/89464929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/weixin_34342207/article/details/89464929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_default&amp;utm_relevant_index=2</a></p>
<ol>
<li>merge时有冲突，合并时发生了什么</li>
<li>merge时的diff对比怎么做到的</li>
<li>revert时候发生了什么</li>
<li>rebase的时候做了什么</li>
<li>贮藏是怎么做到了</li>
<li>树状结构仔细讲讲</li>
</ol>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><h3 id="merge基本原理"><a href="#merge基本原理" class="headerlink" title="merge基本原理"></a>merge基本原理</h3><p>我们知道git 合并文件是以行为单位进行一行一行进行合并的，但是有些时候并不是两行内容不一样git就会报冲突，因为smart git 会帮我们自动帮我们进行取舍，分析出那个结果才是我们所期望的，如果smart git 都无法进行取舍时候才会报冲突，这个时候才需要我们进行人工干预。那git 是如何帮我们进行Smart 操作的呢？</p>
<h3 id="二路合并"><a href="#二路合并" class="headerlink" title="二路合并"></a>二路合并</h3><p>二路合并算法就是讲两个文件进行逐行对别，如果行内容不同就报冲突。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-ac1aa0ab4e4c062d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"><br> 假设对于同一个文件，出现你和其他人一起修改，此时如果git来进行合并，git就懵逼了，因为Git既不敢得罪你(Mine)，也不能得罪他们(Theirs) 无理无据，git只能让你自己搞了，但是这种情况太多了而且也没有必要…</p>
<h3 id="三路合并"><a href="#三路合并" class="headerlink" title="三路合并"></a>三路合并</h3><p>三路合并就是先找出一个基准，然后以基准为Base 进行合并，如果2个文件相对基准(base)都发生了改变 那git 就报冲突，然后让你人工决断。否则，git将取相对于基准(base)变化的那个为最终结果。<br> 这样当git进行合并的时候，git就知道是其他人修改了，本地没有更改，git就会自动把最终结果变成如下：<br><img src="https://upload-images.jianshu.io/upload_images/11893784-6b0f41a62e828d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"><br>如果换成下面的这样，就需要人工解决了:<br><img src="https://upload-images.jianshu.io/upload_images/11893784-9a84cfdfccaf0b13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="递归三路合并原理"><a href="#递归三路合并原理" class="headerlink" title="递归三路合并原理"></a>递归三路合并原理</h4><p>我们来看这样一个例子 现在如果我们要合并 ⑦(source) -&gt; ⑥(destination)：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-17049a5c52342eff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>简短描述下 如何会出现上面的图：</p>
<p><strong>我们分别来看：</strong></p>
<p>如果选择③作为公共祖先 根据最基本的三路合并，可以看到最终结果⑧ 将需要手动解决冲突 &#x2F;foo.c &#x3D; BC???</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-d3f4ee2ff49ad2e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"><br> 如果选择④作为公共祖先 根据最基本的三路合并，可以看到最终结果⑧ 将得到 &#x2F;foo.c&#x3D;C</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-dd7c37d9ad0131d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1038/format/webp" alt="img"></p>
<p>Git 其实是这样进行合并的：</p>
<ul>
<li>git 既不是直接用③，也不是用④，而是将2个祖先进行合并成一个虚拟的 X &#x2F;foo.c &#x3D; B, 因为③ 和 ④ 公共祖先是 〇&#x2F;foo.c &#x3D; A</li>
<li>git 用 X 做为 base 合并 ⑥ 和 ⑦ 结果就是 &#x2F;foo.c &#x3D; C</li>
</ul>
<p>那什么又叫递归(recursive)合并呢 ? 我们合并 ⑥ 和 ⑦ 的时候，我们将其 2 个公共祖先③ 和 ④ 进行 merge 为 X ,在合并 ③ 和 ④时候 我们又需要找到 他们的公共祖先，此时可能又有多个公共祖先，我们又需要将他们先进行合并，如此就是递归了 也就是 recursive merge，如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-4e9f5fa2d10b21ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1178/format/webp" alt="img"></p>
<h3 id="合并策略（git-merge）"><a href="#合并策略（git-merge）" class="headerlink" title="合并策略（git merge）"></a>合并策略（git merge）</h3><p>当项目中包含多条功能分支时，有时就需要使用 git merge 命令，指定将某个分支的提交合并到当前分支。Git 中有两个合并策略：fast-forward 和 no-fast-forward。</p>
<h4 id="fast-forward"><a href="#fast-forward" class="headerlink" title="fast-forward"></a>fast-forward</h4><p>fast-forward（–ff） 意为快进式合并，如果当前分支在合并分支前，没有做过额外提交。那么合并分支的过程不会产生的新的提交记录，而是直接将分支上的提交添加进来，这称为 fast-forward 合并。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-501af1daa07fa1ec.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"><br>很多时候我们在找2个修改集合X,Y 公共祖先的时候，会发现公共祖先就是他们中的一个，此时我们进行merge 的时候，就是Fast-Forward即可，不会产生一个新的Commit 用于merge X和Y 。看懂下面这个例子你就明白了：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/11893784-60de2a661410443b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>当merge ② 和 ⑥时候 由于②是公共祖先，所以进行Fast-Forward 合并，直接指向⑥ 不用生成一个新的⑧进行merge了。</p>
<h4 id="no-fast-forward"><a href="#no-fast-forward" class="headerlink" title="no-fast-forward"></a>no-fast-forward</h4><p>no-fast-forward（–no-ff）意为非快进式合并，fast-forward的场景很少遇到，基本是：在当前分支分离出子分支后（比如分支dev），后续会有其他分支合并进来的修改，而分离出的dev分支也做了修改。这个时候再使用git merge，就会触发 no-fast-forward 策略了。</p>
<p>在 no-fast-forward 策略下，Git 会在当前分支（active branch）额外创建一个新的 合并提交（merging commit）。这条提交记录既指向当前分支，又指向合并分支。<br><img src="https://upload-images.jianshu.io/upload_images/11893784-33e3fb9b10bdbc37.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<h2 id="frevert-amp-reset"><a href="#frevert-amp-reset" class="headerlink" title="frevert &amp; reset"></a>frevert &amp; reset</h2><p>在使用Git的过程中。某些时候，当你不小心改错了内容，或者错误地在本地commit了某些本不该提交的修改，我们就需要进行版本的回退。版本回退最常用的命令包括<code>git reset</code>和<code>git revert</code>。这两个命令允许我们在版本的历史之间穿梭。</p>
<h3 id="Git-reset"><a href="#Git-reset" class="headerlink" title="Git reset"></a>Git reset</h3><p><code>git reset</code> 命令是用来将当前 branch 重置到另外一个 commit 的，这个动作可能同时影响到 index 以及 work directory。先举个例子，来一个感性的认识。现在有一个hotfix分支。</p>
<p><img src="https://lushunjian.github.io/blog/2019/02/14/Git%E7%9A%84%E5%8E%9F%E7%90%86/git6.png" alt="img"></p>
<p>在执行下面这两条命令让 hotfix分支向后回退两个提交。上图就是命令执行前后，分支状态的对比。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout hotfix</span><br><span class="line">git reset HEAD~2</span><br></pre></td></tr></table></figure>

<p>hotfix 分支末端的两个提交现在变成了孤儿提交。下次 Git 执行垃圾回收的时候，这两个提交会被删除。如果你的提交还没有共享给别人，可以用<code>git reset</code>撤销这些提交。因此<code>git reset</code>的使用场景是在本地版本需要回退时使用（前提是没有推送到远程库）。回退前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本；要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<p>如果你不想保留修改的文件，可以使用–hard参数直接回退到指定的commit，该参数会将HEAD指向该commit，并且工作区中的文件也会和该comit保持一致，该commit后的修改会被直接丢弃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD --hard</span><br><span class="line">HEAD is now at 4f73993 some change</span><br><span class="line">$ git status</span><br><span class="line">On branch work</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>

<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>Git revert用来撤销某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交。<code>git revert</code>是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</p>
<p><code>git revert</code>和<code>git reset</code>都可以进行版本的回退，将工作区回退到历史的某个状态，二者有如下的区别：</p>
<ul>
<li><code>git revert</code>是用一次新的commit来回滚之前的commit，而git reset是直接删除指定的commit（并没有真正的删除，通过<code>git reflog</code>可以找回），这是二者最显著的区别；</li>
<li><code>git reset</code> 是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容；</li>
</ul>
<p>使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的。</p>
<p>git revert 命令的好处就是不会丢掉别人的提交，即使你撤销后覆盖了别人的提交，他更新代码后，可以在本地用 reset 向前回滚，找到自己的代码，然后拉一下分支，再回来合并上去就可以找回被你覆盖的提交了。</p>
<p>通过git revert回退刚才的改动，或者修改代码后再次提交，但这样的话你的提交log会显得非常凌乱；</p>
<p>如果不想把中间过程的commit push到远程仓库，可以通过git reset 回退刚才的改动。</p>
<h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>拣选会提取某次提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入特性分支中的某个提交时很有用。</p>
<p>假设你的项目提交历史如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20181028121921915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0OTA4OTY=,size_27,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>如果你希望将提交 e43a6 拉取到 master 分支，你可以运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前在master</span><br><span class="line">git cherry-pick e43a6</span><br></pre></td></tr></table></figure>



<p>这样会拉取和 e43a6 相同的更改，但是因为应用的日期不同，你会得到一个新的提交 SHA-1 值。 现在你的历史会变成这样：</p>
<p><img src="https://img-blog.csdnimg.cn/20181028121945114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0OTA4OTY=,size_27,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p><code>git rebase</code> 命令的文档描述是 <code>Reapply commits on top of another base tip</code>，从字面上理解是「在另一个基端之上重新应用提交」，这个定义听起来有点抽象，换个角度可以理解为「将分支的基础从一个提交改成另一个提交，使其看起来就像是从另一个提交中创建了分支一样」，如下图：</p>
<p><img src="https://www.waynerv.com/images/git-rebase-visual.png" alt="git-rebase.png"></p>
<p>假设我们从 <code>Master</code> 的提交 A 创建了 <code>Feature</code> 分支进行新的功能开发，这时 A 就是 <code>Feature</code> 的基端。接着 <code>Matser</code> 新增了两个提交 B 和 C， <code>Feature</code> 新增了两个提交 D 和 E。现在我们出于某种原因，比如新功能的开发依赖 B、C 提交，需要将 <code>Master</code> 的两个新提交整合到 <code>Feature</code> 分支，为了保持提交历史的整洁，我们可以切换到 <code>Feature</code> 分支执行 <code>rebase</code> 操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p><code>rebase</code> 的执行过程是首先找到这两个分支（即当前分支 <code>Feature</code>、 <code>rebase</code> 操作的目标基底分支 <code>Master</code>） 的最近共同祖先提交 A，然后对比当前分支相对于该祖先提交的历次提交（D 和 E），提取相应的修改并存为临时文件，然后将当前分支指向目标基底 <code>Master</code> 所指向的提交 C, 最后以此作为新的基端将之前另存为临时文件的修改依序应用。</p>
<p>我们也可以按上文理解成将 <code>Feature</code> 分支的基础从提交 A 改成了提交 C，看起来就像是从提交 C 创建了该分支，并提交了 D 和 E。但实际上这只是「看起来」，在内部 Git 复制了提交 D 和 E 的内容，创建新的提交 D’ 和 E’ 并将其应用到特定基础上（A→B→C）。尽管新的 <code>Feature</code> 分支和之前看起来是一样的，但它是由全新的提交组成的。</p>
<p><code>rebase</code> 操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。</p>
<p><code>rebase</code> 通常用于重写提交历史。下面的使用场景在大多数 Git 工作流中是十分常见的：</p>
<ul>
<li>我们从 <code>master</code> 分支拉取了一条 <code>feature</code> 分支在本地进行功能开发</li>
<li>远程的 <code>master</code> 分支在之后又合并了一些新的提交</li>
<li>我们想在 <code>feature</code> 分支集成 <code>master</code> 的最新更改</li>
</ul>
<h3 id="rebase-和-merge-的区别"><a href="#rebase-和-merge-的区别" class="headerlink" title="rebase 和 merge 的区别"></a><a target="_blank" rel="noopener" href="https://www.waynerv.com/posts/git-rebase-intro/#contents:rebase-%E5%92%8C-merge-%E7%9A%84%E5%8C%BA%E5%88%AB">rebase 和 merge 的区别</a></h3><p>以上场景同样可以使用 <code>merge</code> 来达成目的，但使用 <code>rebase</code> 可以使我们保持一个线性且更加整洁的提交历史。假设我们有如下分支：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  D---E feature</span><br><span class="line"> /</span><br><span class="line">A---B---C master</span><br></pre></td></tr></table></figure>

<p>现在我们将分别使用 <code>merge</code> 和 <code>rebase</code>，把 <code>master</code> 分支的 B、C 提交集成到 <code>feature</code> 分支，并在 <code>feature</code> 分支新增一个提交 F，然后再将 <code>feature</code> 分支合入 <code>master</code> ，最后对比两种方法所形成的提交历史的区别。</p>
<ul>
<li><p>使用 <code>merge</code></p>
<ol>
<li>切换到 <code>feature</code> 分支： <code>git checkout feature</code>。</li>
<li>合并 <code>master</code> 分支的更新： <code>git merge master</code>。</li>
<li>新增一个提交 F： <code>git add . &amp;&amp; git commit -m &quot;commit F&quot;</code> 。</li>
<li>切回 <code>master</code> 分支并执行快进合并： <code>git chekcout master &amp;&amp; git merge feature</code>。</li>
</ol>
<p>  执行过程如下图所示：</p>
<p>  <img src="https://www.waynerv.com/images/Dec-30-2020-merge-example.gif" alt="Dec-30-2020-merge-example"></p>
<p>  我们将得到如下提交历史：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 6fa5484 (HEAD -&gt; master, feature) commit F</span><br><span class="line">*   875906b Merge branch &#x27;master&#x27; into feature</span><br><span class="line">|\  </span><br><span class="line">| | 5b05585 commit E</span><br><span class="line">| | f5b0fc0 commit D</span><br><span class="line">* * d017dff commit C</span><br><span class="line">* * 9df916f commit B</span><br><span class="line">|/  </span><br><span class="line">* cb932a6 commit A</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>rebase</code></p>
<p>  步骤与使用 <code>merge</code> 基本相同，唯一的区别是第 2 步的命令替换成： <code>git rebase master</code>。</p>
<p>  执行过程如下图所示：</p>
<p>  <img src="https://www.waynerv.com/images/Dec-30-2020-rebase-example.gif" alt="Dec-30-2020-rebase-example"></p>
<p>  我们将得到如下提交历史：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 74199ce (HEAD -&gt; master, feature) commit F</span><br><span class="line">* e7c7111 commit E</span><br><span class="line">* d9623b0 commit D</span><br><span class="line">* 73deeed commit C</span><br><span class="line">* c50221f commit B</span><br><span class="line">* ef13725 commit A</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以看到，使用 <code>rebase</code> 方法形成的提交历史是完全线性的，同时相比 <code>merge</code> 方法少了一次 <code>merge</code> 提交，看上去更加整洁。</p>
<h3 id="为什么要保持提交历史的整洁"><a href="#为什么要保持提交历史的整洁" class="headerlink" title="为什么要保持提交历史的整洁"></a><a target="_blank" rel="noopener" href="https://www.waynerv.com/posts/git-rebase-intro/#contents:%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BF%9D%E6%8C%81%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E7%9A%84%E6%95%B4%E6%B4%81">为什么要保持提交历史的整洁</a></h3><p>一个看上更整洁的提交历史有什么好处？</p>
<ol>
<li>满足某些者的洁癖。</li>
<li>当你因为某些 bug 需要回溯提交历史时，更容易定位到 bug 是从哪一个提交引入。尤其是当你需要通过 <code>git bisect</code> 从几十上百个提交中排查 bug，或者有一些体量较大的功能分支需要频繁的从远程的主分支拉取更新时。</li>
</ol>
<p>使用 <code>rebase</code> 来将远程的变更整合到本地仓库是一种更好的选择。用 <code>merge</code> 拉取远程变更的结果是，每次你想获取项目的最新进展时，都会有一个多余的 <code>merge</code> 提交。而使用 <code>rebase</code> 的结果更符合我们的本意：我想在其他人的已完成工作的基础上进行我的更改。</p>
<h3 id="其他重写提交历史的方法"><a href="#其他重写提交历史的方法" class="headerlink" title="其他重写提交历史的方法"></a>其他重写提交历史的方法</h3><p>当我们仅仅只想修改最近的一次提交时，使用 <code>git commit --amend</code> 会更加方便。</p>
<p>它适用于以下场景：</p>
<ul>
<li>我们刚刚完成了一次提交，但还没有推送到公共的分支。</li>
<li>突然发现上个提交还留了些小尾巴没有完成，比如一行忘记删除的注释或者一个很小的笔误，我们可以很快速的完成修改，但又不想再新增一个单独的提交。</li>
<li>或者我们只是觉得上一次提交的提交信息写的不够好，想做一些修改。</li>
</ul>
<p>这时候我们可以添加新增的修改（或跳过），使用 <code>git commit --amend</code> 命令执行提交，执行后会进入一个新的编辑器窗口，可以对上一次提交的提交信息进行修改，保存后就会将所做的这些更改应用到上一次提交。</p>
<p>如果我们已经将上一次提交推送到了远程的分支，现在再执行推送将会提示出错并被拒绝，在确保该分支不是一个公共分支的前提下，我们可以使用 <code>git push --force</code> 强制推送。</p>
<p>注意与 <code>rebase</code> 一样，Git 在内部并不会真正地修改并替换上一个提交，而是创建了一个全新的提交并重新指向这个新的提交。</p>
<h3 id="找回丢失的提交"><a href="#找回丢失的提交" class="headerlink" title="找回丢失的提交"></a>找回丢失的提交</h3><p>在交互式模式下进行 <code>rebase</code> 并对提交执行 <code>squash</code> 或 <code>drop</code> 等命令后，会从分支的 <code>git log</code> 中直接删除提交。如果你不小心操作失误，会以为这些提交已经永久消失了而吓出一身冷汗。</p>
<p>但这些提交并没有真正地被删除，如上所说，Git 并不会修改（或删除）原来的提交，而是重新创建了一批新的提交，并将当前分支顶端指向了新提交。因此我们可以使用 <code>git reflog</code> 找到并且重新指向原来的提交来恢复它们，这会撤销整个 <code>rebase</code>。感谢 Git ，即使你执行 <code>rebase</code> 或者 <code>commit --amend</code> 等重写提交历史的操作，它也不会真正地丢失任何提交。</p>
<h4 id="git-reflog-命令"><a href="#git-reflog-命令" class="headerlink" title="git reflog 命令"></a><code>git reflog</code> 命令</h4><p>reflogs 是 Git 用来记录本地仓库分支顶端的更新的一种机制，它会记录所有分支顶端曾经指向过的提交，因此 reflogs 允许我们找到并切换到一个当前没有被任何分支或标签引用的提交。</p>
<p>每当分支顶端由于任何原因被更新（通过切换分支、拉取新的变更、重写历史或者添加新的提交），一条新的记录将被添加到 reflogs 中。如此一来，我们在本地所创建过的每一次提交都一定会被记录在 reflogs 中。即使在重写了提交历史之后， reflogs 也会包含关于分支的旧状态的信息，并允许我们在需要时恢复到该状态。</p>
<p>注意 reflogs 并不会永久保存，它有 90 天的过期时间。</p>
<h4 id="还原提交历史"><a href="#还原提交历史" class="headerlink" title="还原提交历史"></a>还原提交历史</h4><p>我们从上一个例子继续，假设我们想恢复 <code>feature</code> 分支在 <code>rebase</code> 之前的 A→B→C→D→E→F 提交历史，但这时候的 <code>git log</code> 中已经没有后面 5 个提交，所以需要从 reflogs 中寻找，运行 <code>git reflog</code> 结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">64710dc (HEAD -&gt; feature) HEAD@&#123;0&#125;: rebase (continue) (finish): returning to refs/heads/feature</span><br><span class="line">64710dc (HEAD -&gt; feature) HEAD@&#123;1&#125;: rebase (continue): commit H</span><br><span class="line">8ab4506 HEAD@&#123;2&#125;: rebase (continue): commit G</span><br><span class="line">1e186f8 HEAD@&#123;3&#125;: rebase (squash): commit C</span><br><span class="line">c50221f HEAD@&#123;4&#125;: rebase (start): checkout ef1372522cdad136ce7e6dc3e02aab4d6ad73f79</span><br><span class="line">74199ce HEAD@&#123;5&#125;: checkout: moving from master to feature</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>reflogs</code> 完整的记录了我们切换分支并进行 <code>rebase</code> 的全过程，继续向下检索，我们找到了从 <code>git log</code> 中消失的提交 F:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74199ce HEAD@&#123;15&#125;: commit: commit F</span><br></pre></td></tr></table></figure>


<p>接下来我们通过 <code>git reset</code> 将 <code>feature</code> 分支的顶端重新指向原来的提交 F：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 我们想将工作区中的文件也一并还原，因此使用了--hard选项   </span><br><span class="line">$ git reset --hard 74199ce                                      </span><br><span class="line">HEAD 现在位于 74199ce commit F</span><br></pre></td></tr></table></figure>

<p>再运行 <code>git log</code> 会发现一切又回到了从前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">74199cebdd34d107bb67b6da5533a2e405f4c330 (HEAD -&gt; feature) commit F</span><br><span class="line">e7c7111d807c1d5209b97a9c75b09da5cd2810d4 commit E</span><br><span class="line">d9623b0ef9d722b4a83d58a334e1ce85545ea524 commit D</span><br><span class="line">73deeedaa944ef459b17d42601677c2fcc4c4703 commit C</span><br><span class="line">c50221f93a39f3474ac59228d69732402556c93b commit B</span><br><span class="line">ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/14/Swift-Any&AnyObject%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/14/Swift-Any&AnyObject%20/" class="post-title-link" itemprop="url">Swift-ANY&ANYOBJECT</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-14 09:33:47" itemprop="dateCreated datePublished" datetime="2021-12-14T09:33:47+08:00">2021-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:10:37" itemprop="dateModified" datetime="2022-10-15T10:10:37+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Any</code> 和 <code>AnyObject</code> 是 Swift 中两个妥协的产物，也是很让人迷惑的概念。</p>
<!---more--->

<p>转载自：<a target="_blank" rel="noopener" href="https://swifter.tips/any-anyobject/">https://swifter.tips/any-anyobject/</a></p>
<p>由 <strong>王巍 (@ONEVCAT)</strong> 发布于 2014-11-12</p>
<p><code>Any</code> 和 <code>AnyObject</code> 是 Swift 中两个妥协的产物，也是很让人迷惑的概念。在 Swift 官方编程指南中指出</p>
<blockquote>
<p><code>AnyObject</code> 可以代表任何 <code>class</code> 类型的实例</p>
<p><code>Any</code> 可以表示任意类型，甚至包括方法 (func) 类型</p>
</blockquote>
<p>先来说说 <code>AnyObject</code> 吧。写过 Objective-C 的读者可能会知道在 Objective-C 中有一个叫做 <code>id</code> 的神奇的东西。编译器不会对向声明为 <code>id</code> 的变量进行类型检查，它可以表示任意类的实例这样的概念。在 Cocoa 框架中很多地方都使用了 <code>id</code> 来进行像参数传递和方法返回这样的工作，这是 Objective-C 动态特性的一种表现。现在的 Swift 最主要的用途依然是使用 Cocoa 框架进行 app 开发，因此为了与 Cocoa 架构协作，将原来 <code>id</code> 的概念使用了一个类似的，可以代表任意 <code>class</code> 类型的 <code>AnyObject</code> 来进行替代。</p>
<p>但是两者其实是有本质区别的。在 Swift 中编译器不仅不会对 <code>AnyObject</code> 实例的方法调用做出检查，甚至对于 <code>AnyObject</code> 的所有方法调用都会返回 Optional 的结果。这虽然是符合 Objective-C 中的理念的，但是在 Swift 环境下使用起来就非常麻烦，也很危险。应该选择的做法是在使用时先确定 <code>AnyObject</code> 真正的类型并进行转换以后再进行调用。</p>
<p>假设原来的某个 API 返回的是一个 <code>id</code>，那么在 Swift 中现在就将被映射为 <code>AnyObject?</code> (因为 <code>id</code> 是可以指向 <code>nil</code> 的，所以在这里我们需要一个 Optional 的版本)，虽然我们知道调用来说应该是没问题的，但是我们依然最好这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">someMethod</span>() -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个 AnyObject?，等价于在 Objective-C 中返回一个 id</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> anyObject: <span class="type">AnyObject</span>? <span class="operator">=</span> <span class="type">SomeClass</span>.someMethod()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> someInstance <span class="operator">=</span> anyObject <span class="keyword">as?</span> <span class="type">SomeRealClass</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 这里我们拿到了具体 SomeRealClass 的实例</span></span><br><span class="line"></span><br><span class="line">    someInstance.funcOfSomeRealClass()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们注意到 <code>AnyObject</code> 的定义，可以发现它其实就是一个接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">AnyObject</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别之处在于，所有的 <code>class</code> 都隐式地实现了这个接口，这也是 <code>AnyObject</code> 只适用于 <code>class</code> 类型的原因。而在 Swift 中所有的基本类型，包括 <code>Array</code> 和 <code>Dictionary</code> 这些传统意义上会是 <code>class</code> 的东西，统统都是 <code>struct</code> 类型，并不能由 <code>AnyObject</code> 来表示，于是 Apple 提出了一个更为特殊的 <code>Any</code>，除了 <code>class</code> 以外，它还可以表示包括 <code>struct</code> 和 <code>enum</code> 在内的所有类型。</p>
<p>为了深入理解，举个很有意思的例子。为了实验 <code>Any</code> 和 <code>AnyObject</code> 的特性，在 Playground 里写如下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> swiftInt: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> swiftString: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;miao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array: [<span class="type">AnyObject</span>] <span class="operator">=</span> []</span><br><span class="line">array.append(swiftInt)</span><br><span class="line">array.append(swiftString)</span><br></pre></td></tr></table></figure>

<p>我们在这里声明了一个 <code>Int</code> 和一个 <code>String</code>，按理说它们都应该只能被 <code>Any</code> 代表，而不能被 <code>AnyObject</code> 代表的。但是你会发现这段代码是可以编译运行通过的。那是不是说其实 Apple 的编程指南出错了呢？不是这样的，你可以打印一下 <code>array</code>，就会发现里面的元素其实已经变成了 <code>NSNumber</code> 和 <code>NSString</code> 了，这里发生了一个自动的转换。因为我们 <code>import</code> 了 <code>UIKit</code> (其实这里我们需要的只是 <code>Foundation</code>，而在导入 <code>UIKit</code> 的时候也会同时将 <code>Foundation</code> 导入)，在 Swift 和 Cocoa 中的这几个对应的类型是可以进行自动转换的。因为我们显式地声明了需要 <code>AnyObject</code>，编译器认为我们需要的的是 Cocoa 类型而非原生类型，而帮我们进行了自动的转换。</p>
<p>在上面的代码中如果我们把 <code>import UIKit</code> 去掉的话，就会得到无法适配 <code>AnyObject</code> 的编译错误了。我们需要做的是将声明 <code>array</code> 时的 <code>[AnyObject]</code> 换成 <code>[Any]</code>，就一切正确了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> swiftInt: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> swiftString: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;miao&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array: [<span class="keyword">Any</span>] <span class="operator">=</span> []</span><br><span class="line">array.append(swiftInt)</span><br><span class="line">array.append(swiftString)</span><br><span class="line">array</span><br></pre></td></tr></table></figure>

<p>顺便值得一提的是，只使用 Swift 类型而不转为 Cocoa 类型，对性能的提升是有所帮助的，所以我们应该尽可能地使用原生的类型。</p>
<p>其实说真的，使用 <code>Any</code> 和 <code>AnyObject</code> 并不是什么令人愉悦的事情，正如开头所说，这都是为妥协而存在的。如果在我们自己的代码里需要大量经常地使用这两者的话，往往意味着代码可能在结构和设计上存在问题，应该及时重新审视。简单来说，我们最好避免依赖和使用这两者，而去尝试明确地指出确定的类型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/12/14/Swift-Protocol%20Composition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/14/Swift-Protocol%20Composition/" class="post-title-link" itemprop="url">Swift-Protocol Composition</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-14 09:33:47" itemprop="dateCreated datePublished" datetime="2021-12-14T09:33:47+08:00">2021-12-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:16:23" itemprop="dateModified" datetime="2022-10-15T10:16:23+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Any</code> 这个类型的定义十分奇怪，它是一个 <code>protocol&lt;&gt;</code> 的同名类型</p>
<!---more--->

<p>转载来自：<a target="_blank" rel="noopener" href="https://swifter.tips/protocol-composition/">https://swifter.tips/protocol-composition/</a></p>
<p>在 Swift 中我们可以使用 <code>Any</code> 来表示任意类型 (如果你对此感到模糊或者陌生的话，可以先看看 Apple 的 Swift 官方教程或者本书的<a target="_blank" rel="noopener" href="https://swifter.tips/any-anyobject/">这篇 tip</a>)，充满好奇心的同学可能已经发现，<code>Any</code> 这个类型的定义十分奇怪，它是一个 <code>protocol&lt;&gt;</code> 的同名类型。</p>
<p><code>protocol&lt;&gt;</code> 这样形式的写法在日常 Swift 使用中其实并不多见，这其实是 Swift 的接口组合的用法。标准的语法形式是下面这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span>&lt;<span class="title class_">ProtocolA</span>, <span class="title class_">ProtocolB</span>, <span class="title class_">ProtocolC</span>&gt;</span><br></pre></td></tr></table></figure>

<p>尖括号内是具体接口的名称，这里表示将名称为 <code>ProtocolA</code>，<code>ProtocolB</code> 以及 <code>ProtocolC</code> 的接口组合在一起的一个新的匿名接口。实现这个匿名接口就意味着要同时实现这三个接口所定义的内容。所以说，这里的 protocol 组合的写法和下面的新声明的 <code>ProtocolD</code> 是相同的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">ProtocolD</span>: <span class="title class_">ProtocolA</span>, <span class="title class_">ProtocolB</span>, <span class="title class_">ProtocolC</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，在 <code>Any</code> 定义的时候的里面什么都不写的 <code>protocol&lt;&gt;</code> 是什么意思呢？从语意上来说，这代表一个 “需要实现空接口的接口”，其实就是任意类型的意思了。</p>
<p>除了可以方便地表达空接口这一概念以外，protocol 的组合相比于新创建一个接口的最大区别就在于其匿名性。有时候我们可以借助这个特性写出更清晰的代码。因为 Swift 的类型组织是比较松散的，你的类型可以由不同的 <code>extension</code> 来定义实现不同的接口，Swift 也并没有要求它们在同一个文件中。这样，当一个类型实现了很多接口时，在使用这个类型的时候我们很可能在不查询相关代码的情况下很难知道这个类型所实现的接口。</p>
<p>举个理想化的例子，比如我们有下面的三个接口，分别代表了三种动物的叫的方式，而有一种谜之动物，同时实现了这三个接口：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">KittenLike</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">meow</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">DogLike</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bark</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">TigerLike</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">aou</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MysteryAnimal</span>: <span class="title class_">KittenLike</span>, <span class="title class_">DogLike</span>, <span class="title class_">TigerLike</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">meow</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;meow&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bark</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bark&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">aou</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aou&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们想要检查某种动物作为宠物的时候的叫声的话，我们可能要重新定义一个叫做 <code>PetLike</code> 的接口，表明其实现 <code>KittenLike</code> 和 <code>DogLike</code>；如果稍后我们又想检查某种动物作为猫科动物的叫声的话，我们也许又要去定义一个叫做 <code>CatLike</code> 这样的实现 <code>KittenLike</code> 和 <code>TigerLike</code> 的接口。最后我们大概会写出这样的东西：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">PetLike</span>: <span class="title class_">KittenLike</span>, <span class="title class_">DogLike</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">CatLike</span>: <span class="title class_">KittenLike</span>, <span class="title class_">TigerLike</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SoundChecker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkPetTalking</span>(<span class="params">pet</span>: <span class="type">PetLike</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkCatTalking</span>(<span class="params">cat</span>: <span class="type">CatLike</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然没有引入定义任何新的内容，但是为了实现这个需求，我们还是添加了两个空 protocol，这可能会让人困惑，代码的使用者 (也包括一段时间后的你自己) 可能会去猜测 <code>PetLike</code> 和 <code>CatLike</code> 的作用 – 其实它们除了标注以外并没有其他作用。借助 protocol 组合的特性，我们可以很好的解决这个问题。protocol 组合是可以使用 <a target="_blank" rel="noopener" href="https://swifter.tips/typealias/">typealias</a> 来命名的，于是可以将上面的新定义 protocol 的部分换为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">PetLike</span> <span class="operator">=</span> <span class="keyword">protocol</span>&lt;<span class="title class_">KittenLike</span>, <span class="title class_">DogLike</span>&gt;</span><br><span class="line"><span class="title class_">typealias</span> <span class="title class_">CatLike</span> = <span class="title class_">protocol</span>&lt;<span class="title class_">KittenLike</span>, <span class="title class_">TigerLike</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这样既保持了可读性，也没有多定义不必要的新类型。</p>
<p>另外，其实如果这两个临时接口我们就只用一次的话，如果上下文里理解起来不会有困难，我们完全可以直接将它们匿名化，变成下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SoundChecker</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkPetTalking</span>(<span class="params">pet</span>: <span class="keyword">protocol</span><span class="operator">&lt;</span><span class="type">KittenLike</span>, <span class="type">DogLike</span><span class="operator">&gt;</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">checkCatTalking</span>(<span class="params">cat</span>: <span class="keyword">protocol</span><span class="operator">&lt;</span><span class="type">KittenLike</span>, <span class="type">TigerLike</span><span class="operator">&gt;</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的好处是定义和使用的地方更加接近，这在代码复杂的时候读代码时可以少一些跳转，多一些专注。但是因为使用了匿名的接口组合，所以能表达的信息毕竟少了一些。如果要实际使用这种方法的话，还是需要多多斟酌。</p>
<p>虽然这一节已经够长了，不过我还是想多提一句关于实现多个接口时接口内方法冲突的解决方法。因为在 Swift 的世界中没有人限制或者保证过不同接口的方法不能重名，所以这是有可能出现的情况。比如有 <code>A</code> 和 <code>B</code> 两个接口，定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protocol</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个接口中 <code>bar()</code> 只有返回值的类型不同。我们如果有一个类型 <code>Class</code> 同时实现了 A 和 B，我们要怎么才能避免和解决调用冲突呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>: <span class="title class_">A</span>, <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">bar</span>() -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hi&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，对于 <code>bar()</code>，只要在调用前进行类型转换就可以了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance <span class="operator">=</span> <span class="type">Class</span>()</span><br><span class="line"><span class="keyword">let</span> num <span class="operator">=</span> (instance <span class="keyword">as</span> <span class="type">A</span>).bar()  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> str <span class="operator">=</span> (instance <span class="keyword">as</span> <span class="type">B</span>).bar()  <span class="comment">// &quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果我们这里不进行类型转换的话就会报错<code>Ambiguous use of &#39;bar()&#39;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/27/iOS-URLSession/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/27/iOS-URLSession/" class="post-title-link" itemprop="url">iOS-URLSession</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-27 09:41:00" itemprop="dateCreated datePublished" datetime="2021-10-27T09:41:00+08:00">2021-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:16:16" itemprop="dateModified" datetime="2022-10-15T10:16:16+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>URLSession 在 2013年随着 iOS7 的发布一起面世的，苹果对它的定位是作为 NSURLConnection 的替代者，在 iOS9 之后苹果官方已经移除了 NSURLConnection，我们使用最广泛的第三方框架：AFNetworking、SDWebImage 的最新版也都已经全部使用了URLSession</p>
<!---more--->

<p>URLSession 指的也不仅是同名类 URLSession，还包括一系列相互关联的类，包括：NSURLSession、NSURLSessionConfiguration 以及 NSURLSessionTask 的 4 个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask、NSURLSessionStreamTask（iOS 9 新增） ，还包括之前就存在的两个类；NSURLRequest 与 NSURLCache</p>
<h2 id="URLSession的用法"><a href="#URLSession的用法" class="headerlink" title="URLSession的用法"></a>URLSession的用法</h2><p>好了 现在我们从URLSession的用法开始聊起</p>
<p>NSURLSession 本身是不会进行请求的，而是通过创建 task 的形式进行网络请求，同一个 URLSession 可以创建多个 task，并且这些 task 之间的 cache 和 cookie 是共享的。<br>NSURLSession 的使用有如下几步:</p>
<ol>
<li>创建一个 NSURLSession 对象</li>
<li>使用 NSURLSession 对象创建一个 Task</li>
<li>启动执行 Task（ resume( ) 方法）</li>
</ol>
<h2 id="URLSession-的创建"><a href="#URLSession-的创建" class="headerlink" title="URLSession 的创建"></a>URLSession 的创建</h2><p>有两种方式创建 NSURLSession 对象：</p>
<ul>
<li>默认 NSURLSession 对象（shared）</li>
<li>自定义 NSURLSession 对象（利用configuration配置）</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建默认的Session对象，会使用全局的Cache，cookie和证书</span></span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义创建Session对象需要先创建配置对象</span></span><br><span class="line"><span class="keyword">let</span> config <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.default</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义创建Session对象</span></span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: config)</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种创建方式</span></span><br><span class="line"><span class="comment">//init(configuration: URLSessionConfiguration, delegate: URLSessionDelegate?, delegateQueue: OperationQueue?)</span></span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: config, delegate: <span class="keyword">self</span> <span class="keyword">as!</span> <span class="type">URLSessionDelegate</span>, delegateQueue: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用代理可以处理处理身份验证失败、重定向、进度更新等功能</p>
<p>The queue should be a serial queue, in order to ensure the correct ordering of callbacks. If nil, the session creates a serial operation queue for performing all delegate method calls and completion handler calls.<br>队列应该是一个串行队列，以确保回调的正确顺序。 如果为零，会话将创建一个串行操作队列，用于执行所有委托方法调用和完成处理程序调用</p>
</blockquote>
<h2 id="URLSessionConfiguration"><a href="#URLSessionConfiguration" class="headerlink" title="URLSessionConfiguration"></a>URLSessionConfiguration</h2><p>URLSessionConfiguration可以配置会话(session)属性像timeout、HTTP header、缓存策略。</p>
<p>URLSession 在初始化时会把配置它的 URLSessionConfiguration 对象进行一次 copy，并保存到自己的 configuration 属性中，而且这个属性是只读的，因此之后再修改最初配置 session  的那个 configuration 对象对于session 是没有影响的，也就是说，onfiguration&#96;只在初始化时被读取一次，之后都是不会变化的，如果想更改传输策略（modify your transfer policies），那就得修改完configuration对象之后，再创建一个新的 session 对象</p>
<h4 id="会话类型（Types-of-URL-Sessions）"><a href="#会话类型（Types-of-URL-Sessions）" class="headerlink" title="会话类型（Types of URL Sessions）"></a>会话类型（Types of URL Sessions）</h4><p>URLSession支持以下三种会话模式：</p>
<ol>
<li>默认会话模式（default）：默认模式，基于磁盘缓存的持久化策略，使用用户keychain中保存的证书进行认证授权。这个共享Cookie，缓存和证书，默认的shared的类型就是这个，只不过这个可以通过configuration进行更多配置，但是shared不支持其他的配置。</li>
<li>瞬时会话模式（ephemeral）：不储存任何数据在磁盘中，所有数据都保存在内存中，当会话结束后，缓存数据将被清空。</li>
<li>后台会话模式（background）：该模式类似于默认模式，只是将上传和下载移至后台处理，需要一个提供一个String类型的 identifier 用于标识后台会话。</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configDefault <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.default</span><br><span class="line"><span class="comment">//1、默认会话模式（default）</span></span><br><span class="line"><span class="keyword">let</span> configEphemeral <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.ephemeral</span><br><span class="line"><span class="comment">//2、瞬时会话模式（ephemeral）</span></span><br><span class="line"><span class="keyword">let</span> configBackground <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment">//3、后台会话模式（background）</span></span><br></pre></td></tr></table></figure>

<p>创建了URLSessionConfiguration就可以给他设置各种属性，详细可以看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration">官方文档</a></p>
<h4 id="Request-Timeout"><a href="#Request-Timeout" class="headerlink" title="Request Timeout"></a>Request Timeout</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.timeoutIntervalForRequest <span class="operator">=</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>request 请求超时时间，默认60s</p>
<h4 id="Resource-Timeout"><a href="#Resource-Timeout" class="headerlink" title="Resource Timeout"></a>Resource Timeout</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.timeoutIntervalForResource <span class="operator">=</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
<p>任务等待整个资源加载的超时时间（单位是秒），但是默认值是7天，就很离谱</p>
<h4 id="Waits-For-Connectivity-iOS-11"><a href="#Waits-For-Connectivity-iOS-11" class="headerlink" title="Waits For Connectivity (iOS 11)"></a>Waits For Connectivity (iOS 11)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.waitsForConnectivity <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>indicates whether the session should wait for connectivity to become available, or fail immediately.</p>
<p>这个属性让这个暂时不可用的连接变成等待可用而不是立即失败。比如说有个连接必须要VPN，但是现在只有蜂窝网，这个属性就可以让这个连接等到有VPN的时候在进行连接。这个属性的默认值是<code>false</code>，如果连接不可用的时候会立即失败然后报错。</p>
<p>这个等待时间由上面的提到的 timeoutIntervalForResource 确定（所以一定要配置resource time，别用他七天的默认值）。在这期间后台会话会一直等待连接。</p>
<p>如果用代理的话，在等待连接的时候会调用<code>urlSession(_:taskIsWaitingForConnectivity:)</code></p>
<h4 id="Allows-Cellular-Access"><a href="#Allows-Cellular-Access" class="headerlink" title="Allows Cellular Access"></a>Allows Cellular Access</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.allowsCellularAccess <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>是否允许会话使用蜂窝网络，默认是<code>true</code>，在iOS 13之后提供了替代方法<code>allows expensive network access</code></p>
<h4 id="Allows-Low-Data-Mode-Access-iOS-13"><a href="#Allows-Low-Data-Mode-Access-iOS-13" class="headerlink" title="Allows Low Data Mode Access (iOS 13)"></a>Allows Low Data Mode Access (iOS 13)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.allowsConstrainedNetworkAccess <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>是否允许会话使用受限网络接口进行连接，默认为<code> true</code>。 受限网络接口是用户在设备设置中打开“低数据模式”的接口。</p>
<h4 id="Allows-Expensive-Network-Access-iOS-13"><a href="#Allows-Expensive-Network-Access-iOS-13" class="headerlink" title="Allows Expensive Network Access (iOS 13)"></a>Allows Expensive Network Access (iOS 13)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.allowsExpensiveNetworkAccess <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>会话是否允许通过“昂贵的”网络接口进行连接，默认为 true。这个ExpensiveNetwork是由系统决定的，比如说热点还有流量。</p>
<p>一般可以结合上面提到的低数据模式还有网络等待来组合使用，防止在昂贵且受限的网络上进行非必要的网络活动：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configuration.waitsForConnectivity <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">configuration.allowsConstrainedNetworkAccess <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">configuration.allowsExpensiveNetworkAccess <span class="operator">=</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h4><p>在默认的会话配置中，利用app来直接配置缓存:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shared <span class="operator">=</span> <span class="type">URLCache</span>.shared</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shared.memoryCapacity) <span class="comment">// 512000 (512Kb)</span></span><br><span class="line"><span class="built_in">print</span>(shared.diskCapacity)   <span class="comment">// 10000000 (10Mb)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shared.currentMemoryUsage)</span><br><span class="line"><span class="built_in">print</span>(shared.currentDiskUsage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Increase memory cache size</span></span><br><span class="line">shared.memoryCapacity <span class="operator">=</span> <span class="number">500_000_000</span> <span class="comment">// 500Mb</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过Configuration来配置缓存，使用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410148-urlcache"><code>var urlCache: URLCache?</code></a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cache <span class="operator">=</span> <span class="type">URLCache</span>(memoryCapacity: <span class="number">500_000_000</span>, </span><br><span class="line">                      diskCapacity: <span class="number">1_000_000_000</span>)</span><br><span class="line">configuration.urlCache <span class="operator">=</span> cache</span><br></pre></td></tr></table></figure>

<p>也可以直接禁用缓存</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.urlCache <span class="operator">=</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h4 id="HTTP-Headers"><a href="#HTTP-Headers" class="headerlink" title="HTTP Headers"></a>HTTP Headers</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configuration.httpAdditionalHeaders <span class="operator">=</span> [<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;MyApp 1.0&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>使用<code>httpAdditionalHeaders</code>可以来配置请求头</p>
<h2 id="URLSessionTask"><a href="#URLSessionTask" class="headerlink" title="URLSessionTask"></a>URLSessionTask</h2><p>URLSessionTask是一个表示任务对象的抽象类，可以在URLSession的实例上调用调用对应的方法来创建任务，一共有四种任务类型：</p>
<ol>
<li><p>URLSessionDataTask：处理从HTTP get请求中从服务器获取数据到内存中</p>
</li>
<li><p>URLSessionUploadTask：上传硬盘中的文件到服务器，一般是HTTP POST 或 PUT方式</p>
</li>
<li><p>URLSessionDownloadTask：从远程服务器下载文件到临时文件位置</p>
</li>
<li><p>URLSessionStreamTask：基于流的URL会话任务，提供了一个通过 URLSession 创建的 TCP&#x2F;IP 连接接口</p>
</li>
</ol>
<blockquote>
<p>注意：</p>
<p>我们的网络任务默认是挂起状态的<code>suspend</code>，在获取到 <code>dataTask</code>以后需要使用 <code>resume()</code> 函数来恢复或者开始请求。</p>
<blockquote>
<ul>
<li>resume()：启动任务</li>
<li>suspend()：暂停任务</li>
<li>cancel()：取消任务</li>
</ul>
</blockquote>
</blockquote>
<h4 id="URLSessionDataTask"><a href="#URLSessionDataTask" class="headerlink" title="URLSessionDataTask"></a>URLSessionDataTask</h4><p>URLSessionDataTask是URLSessionTask的一个实体子类，他的方法都定义在了URLSessionTask基之中。<br>URLSessionDataTask是平时使用频率最高的，平时使用的POST还有GET请求都是通过它来实现的。URLSessionDataTask请求后将数据作为一个或多个NSData对象直接返回到应用程序（在内存中）。<br>URLSessionDataTask 可以通过 URL 或 URLRequest 创建（使用前者相当于是使用一个对于该 URL 进行标准 GET 请求），如果请求的数据简单并且不需要对获取的数据进行复杂操作，我们使用 Block 处理返回的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 NSURL 创建</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getRequst</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: url<span class="operator">!</span>) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    	<span class="comment">//此处返回的数据是JSON格式的，因此使用NSJSONSerialization进行反序列化处理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data<span class="operator">!</span>, options: .allowFragments)&#123;</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 resume 任务开始运行</span></span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 NSURLRequest 创建 整个POST请求</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">postRequst</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">    <span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/post&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    <span class="comment">//设置请求方式，默认为GET</span></span><br><span class="line">    request.httpMethod <span class="operator">=</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: request) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data<span class="operator">!</span>, options: .allowFragments)&#123;</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上传body data期间，会话周期性的调用他的代理 <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code></li>
<li>在接收到初始响应的时候，会调用代理<code>urlSession(_:dataTask:didReceive:completionHandler:)</code>来检查状态码和头，并可以将data task转为download task</li>
<li>在传输期间会调用代理<code>urlSession(_:dataTask:didReceive:)</code>来让应用获取到已到达的数据</li>
<li>在传输完成后会调用代理<code>urlSession(_:dataTask:willCacheResponse:completionHandler:)</code>来让你决定是否缓存响应</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">sessionWithDelegate</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//delegateQueue 代理方法执行的线程</span></span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: <span class="type">URLSessionConfiguration</span>.default,</span><br><span class="line">                             delegate: <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">URLSessionDataDelegate</span>,</span><br><span class="line">                             delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;https://httpbin.org/get&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.dataTask(with: request)</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MARK: - URLSessionDataDelegate</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>,</span><br><span class="line">                <span class="params">didReceive</span> <span class="params">response</span>: <span class="type">URLResponse</span>,</span><br><span class="line">                <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">URLSession</span>.<span class="type">ResponseDisposition</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接收到服务器的响应&quot;</span>)</span><br><span class="line">    <span class="comment">// 必须设置对响应进行允许处理才会执行后面的操作</span></span><br><span class="line">    completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                <span class="params">dataTask</span>: <span class="type">URLSessionDataTask</span>,</span><br><span class="line">                <span class="params">didReceive</span> <span class="params">data</span>: <span class="type">Data</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该方法可能被调用多次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;接受到服务器的数据&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                <span class="params">task</span>: <span class="type">URLSessionTask</span>,</span><br><span class="line">                <span class="params">didCompleteWithError</span> <span class="params">error</span>: <span class="type">Error</span>?) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请求完成之后调用成功或者失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="URLSessionDownloadTask"><a href="#URLSessionDownloadTask" class="headerlink" title="URLSessionDownloadTask"></a>URLSessionDownloadTask</h4><p>URLSessionDownloadTask用于下载，有两种方式：Block 和 代理，URLSession 在下载文件的时候，是将数据一点点地写入本地的一个临时文件，这个临时文件系统会很很快删除，所以我们需要把文件从这个临时地址移动到一个永久的地址保存起来，这样才算完整的下载完一个文件，另外，使用 NSURLSessionConfiguration 的 background 模式可以做到后台下载，并且即使应用被 Kill 之后也还可以恢复之前的下载任务。</p>
<h4 id="Block方式下载文件"><a href="#Block方式下载文件" class="headerlink" title="Block方式下载文件"></a>Block方式下载文件</h4><p>使用 Block 方式适合下载小文件，并且不需要监听下载进度，并且文件下载完成才会调用 Block。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">downloadTask</span>()  &#123;</span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.shared</span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;https://cdn.sspai.com/2017/06/19/80b932adce51390f8c79070e8839cc95.jpeg&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.downloadTask(with: request) &#123; (location, response, error) <span class="keyword">in</span>   </span><br><span class="line">    <span class="comment">//location 是沙盒中 tmp 文件夹下的一个临时文件路径，tmp 中的文件随时可能被删除，所以我们需要自己需要把下载的文件挪到 Caches 或者 Documents 文件夹中</span></span><br><span class="line">        <span class="keyword">let</span> locationPath <span class="operator">=</span> location<span class="operator">!</span>.path</span><br><span class="line">        <span class="keyword">let</span> documnets <span class="operator">=</span> <span class="type">NSSearchPathForDirectoriesInDomains</span>(.documentDirectory, .userDomainMask, <span class="literal">true</span>).last<span class="operator">!</span> <span class="operator">+</span> <span class="string">&quot;/&quot;</span> <span class="operator">+</span> (response<span class="operator">?</span>.suggestedFilename)<span class="operator">!</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">        &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于NSSearchPathForDirectoriesInDomains</p>
<p>iPhone会为每一个应用程序生成一个私有目录，这个目录位于：&#x2F;Users&#x2F;sundfsun2009&#x2F;Library&#x2F;Application Support&#x2F;iPhone Simulator&#x2F;User&#x2F;Applications下，并随即生成一个数字字母串作为目录名，在每一次应用程序启动时，这个字母数字串都是不同于上一次。</p>
<p>所以通常使用Documents目录进行数据持久化的保存，而这个Documents目录可以通过：NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserdomainMask，true)得到。</p>
</blockquote>
<h4 id="代理方式下载文件"><a href="#代理方式下载文件" class="headerlink" title="代理方式下载文件"></a>代理方式下载文件</h4><p>使用代理方式适合下载大文件，并且可以随时监听文件的下载进度、暂停文件下载等。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">downloadTask</span>()  &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: <span class="type">URLSessionConfiguration</span>.default, delegate: <span class="keyword">self</span> <span class="keyword">as</span> <span class="type">URLSessionDownloadDelegate</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;http://dldir1.qq.com/qqfile/QQforMac/QQ_V5.5.1.dmg&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> task <span class="operator">=</span> session.downloadTask(with: request)</span><br><span class="line">    </span><br><span class="line">    task.resume()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//MARk: - URLSessionDownloadDelegate</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>,</span><br><span class="line">                <span class="params">didWriteData</span> <span class="params">bytesWritten</span>: <span class="type">Int64</span>,</span><br><span class="line">                <span class="params">totalBytesWritten</span>: <span class="type">Int64</span>,</span><br><span class="line">                <span class="params">totalBytesExpectedToWrite</span>: <span class="type">Int64</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下载过程中写入数据会一直调用这个方法</span></span><br><span class="line">    <span class="comment">//didWriteData：之前已经下载完的数据量</span></span><br><span class="line">    <span class="comment">//bytesWritten：本次写入的数据量</span></span><br><span class="line">    <span class="comment">//totalBytesWritten：目前总共写入的数据量</span></span><br><span class="line">    <span class="comment">//totalBytesExpectedToWrite：文件总数据量</span></span><br><span class="line">    <span class="keyword">let</span> progress <span class="operator">=</span> <span class="type">Float</span>(totalBytesWritten)<span class="operator">/</span><span class="type">Float</span>(totalBytesExpectedToWrite)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;totalBytesExpectedToWrite++++<span class="subst">\(progress)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>,</span><br><span class="line">                <span class="params">didResumeAtOffset</span> <span class="params">fileOffset</span>: <span class="type">Int64</span>,</span><br><span class="line">                <span class="params">expectedTotalBytes</span>: <span class="type">Int64</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暂停后恢复下载的代理方法</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">urlSession</span>(<span class="keyword">_</span> <span class="params">session</span>: <span class="type">URLSession</span>,</span><br><span class="line">                    <span class="params">downloadTask</span>: <span class="type">URLSessionDownloadTask</span>,</span><br><span class="line">                    <span class="params">didFinishDownloadingTo</span> <span class="params">location</span>: <span class="type">URL</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下载完成后的代理方法</span></span><br><span class="line">    <span class="keyword">let</span> locationPath <span class="operator">=</span> location.path</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> documnets <span class="operator">=</span> <span class="type">NSSearchPathForDirectoriesInDomains</span>(.documentDirectory, .userDomainMask, <span class="literal">true</span>).last<span class="operator">!</span> <span class="operator">+</span> <span class="string">&quot;/&quot;</span> <span class="operator">+</span> (downloadTask.response<span class="operator">?</span>.suggestedFilename)<span class="operator">!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> <span class="type">FileManager</span>.default.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="断点续传下载文件"><a href="#断点续传下载文件" class="headerlink" title="断点续传下载文件"></a>断点续传下载文件</h4><h4 id="后台下载文件"><a href="#后台下载文件" class="headerlink" title="后台下载文件"></a>后台下载文件</h4><p><a target="_blank" rel="noopener" href="https://xiaovv.me/2017/07/12/Basic-usage-of-NSURLSession/">https://xiaovv.me/2017/07/12/Basic-usage-of-NSURLSession/</a></p>
<h4 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h4><p>NSURLSession 中使用NSURLSessionUploadTask 上传文件，把需要上传的数据以表单的形式拼接在请求体中即可，创建NSURLSessionUploadTask 有以下两种方式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建上传任务，需要提供上传文件二进制数据 */</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">uploadTask</span>(<span class="params">with</span> <span class="params">request</span>: <span class="type">URLRequest</span>,</span><br><span class="line">                 	<span class="params">fromFile</span> <span class="params">fileURL</span>: <span class="type">URL</span>, </span><br><span class="line">                	<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span></span><br><span class="line"><span class="comment">/* 创建上传任务，需要提供上传文件所在的URL路径，不过这个方法常配合“PUT”请求使用 */</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">func</span> <span class="title function_">uploadTask</span>(<span class="params">with</span> <span class="params">request</span>: <span class="type">URLRequest</span>, </span><br><span class="line">                    <span class="params">from</span> <span class="params">bodyData</span>: <span class="type">Data</span>?,</span><br><span class="line">                	<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> (<span class="type">Data</span>?, <span class="type">URLResponse</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Swift</span>.<span class="type">Void</span>) -&gt; <span class="type">URLSessionUploadTask</span></span><br></pre></td></tr></table></figure>

<p>表单拼接格式是固定的，必须严格按照规定的格式设置，具体格式如下:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">--</span>上传标识符\r\n</span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Disposition</span>:form<span class="operator">-</span>data;name<span class="operator">=</span><span class="string">&quot;表单控件名称&quot;</span>;filename<span class="operator">=</span><span class="string">&quot;上传文件名称&quot;</span>\r\n</span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Type</span>: 要上传文件<span class="type">MIME</span> <span class="type">Type</span> \r\n</span><br><span class="line">\r\n</span><br><span class="line">要上传文件二进制数据</span><br><span class="line">\r\n</span><br><span class="line"><span class="operator">--</span>上传标识符\r\n</span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Disposition</span>: form<span class="operator">-</span>data; name<span class="operator">=</span>\<span class="string">&quot;参数名1<span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">参数值1</span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">--上传标识符<span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">Content-Disposition: form-data; name=<span class="subst">\&quot;</span>参数名2<span class="subst">\&quot;</span><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">参数值2</span></span><br><span class="line"><span class="string"><span class="subst">\r</span><span class="subst">\n</span></span></span><br><span class="line"><span class="string">--结束标识符--<span class="subst">\r</span><span class="subst">\n</span></span></span><br></pre></td></tr></table></figure>

<p>举个图片上传拼接文件参数的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标识符可以随意，但是前后必须一致</span></span><br><span class="line"><span class="keyword">let</span> boundary <span class="operator">=</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">uploadFile</span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> request <span class="operator">=</span> <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="string">&quot;http://localhost:8080/Server/upload&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">    request.httpMethod <span class="operator">=</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">    <span class="keyword">let</span> contentType <span class="operator">=</span> <span class="string">&quot;multipart/form-data; charset=utf-8;boundary=&quot;</span> <span class="operator">+</span> boundary</span><br><span class="line">    <span class="comment">// 设置请求头(告诉服务器这次传给你的是文件数据，告诉服务器现在发送的是一个文件上传请求)</span></span><br><span class="line">    request.setValue(contentType, forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>(configuration: <span class="type">URLSessionConfiguration</span>.default, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">    <span class="keyword">let</span> imageData <span class="operator">=</span> <span class="keyword">self</span>.buildBodyData()</span><br><span class="line">    <span class="keyword">let</span> uploadTask <span class="operator">=</span> session.uploadTask(with: request, from: imageData) &#123; (data, respond, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> dic <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">JSONSerialization</span>.jsonObject(with: data<span class="operator">!</span>, options: .mutableLeaves) &#123;</span><br><span class="line">            <span class="built_in">print</span>(dic)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    uploadTask.resume()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">buildBodyData</span>() -&gt; <span class="type">Data</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> bodyStr <span class="operator">=</span> <span class="string">&quot;--&quot;</span> <span class="operator">+</span> boundary <span class="operator">+</span> <span class="string">&quot;<span class="subst">\r</span><span class="subst">\n</span>&quot;</span></span><br><span class="line">    bodyStr.append(<span class="string">&quot;Content-disposition: form-data; name=<span class="subst">\&quot;</span>file<span class="subst">\&quot;</span>; filename=<span class="subst">\&quot;</span>test.png<span class="subst">\&quot;</span>&quot;</span>)</span><br><span class="line">    bodyStr.append(<span class="string">&quot;<span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    bodyStr.append(<span class="string">&quot;Content-Type: image/png&quot;</span>)</span><br><span class="line">    bodyStr.append(<span class="string">&quot;<span class="subst">\r</span><span class="subst">\n</span><span class="subst">\r</span><span class="subst">\n</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> bodyData <span class="operator">=</span> bodyStr.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</span><br><span class="line">    <span class="keyword">let</span> path <span class="operator">=</span> <span class="type">Bundle</span>.main.path(forResource: <span class="string">&quot;minion_03&quot;</span>, ofType: <span class="string">&quot;png&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> imageData <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">Data</span>(contentsOf: <span class="type">URL</span>(fileURLWithPath: path<span class="operator">!</span>)) &#123;  </span><br><span class="line">        bodyData<span class="operator">?</span>.append(imageData)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> endStr <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span><span class="subst">\n</span>--&quot;</span> <span class="operator">+</span> boundary <span class="operator">+</span> <span class="string">&quot;--<span class="subst">\r</span><span class="subst">\n</span>&quot;</span></span><br><span class="line">    bodyData<span class="operator">?</span>.append(endStr.data(using: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)<span class="operator">!</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bodyData<span class="operator">!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="URLSessionStreamTask"><a href="#URLSessionStreamTask" class="headerlink" title="URLSessionStreamTask"></a>URLSessionStreamTask</h4><p>NSURLSessionStreamTask类提供了一个通过NSURLSession创建的TCP&#x2F;IP连接接口。</p>
<p>需要注意的是，由于URLSession采用的是“异步阻塞”模型，所以在实现DownloadTaskDelegate代理方法更新UI时需要将线程切回主线程。</p>
<blockquote>
<p>“阻塞”与”非阻塞”与”同步”与“异步”不能简单的从字面理解，<br>同步与异步同步和异步关注的是<strong>消息通信机制 (synchronous communication&#x2F; asynchronous communication)</strong><br>所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者<strong>主动等待</strong>这个调用的结果。<br>而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，<strong>被调用者</strong>通过状态、通知来<strong>通知调用者</strong>，或通过回调函数处理这个调用。<br>典型的异步编程模型比如Node.js举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。<br>阻塞与非阻塞阻塞和非阻塞关注的是程序在<strong>等待调用结果（消息，返回值）时的状态</strong>。<br>阻塞调用是指调用结果返回之前，当前线程会被<strong>挂起</strong>。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计算机网络学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-23 16:16:55" itemprop="dateCreated datePublished" datetime="2021-03-23T16:16:55+08:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:06:33" itemprop="dateModified" datetime="2022-10-15T10:06:33+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>以TCP&#x2F;IP网络模型分层作为章节，并结合一些实际问题作为例子，包含常见的计算机网络相关问题，内容不断整理更新中</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-17 20:26:32" itemprop="dateCreated datePublished" datetime="2021-03-17T20:26:32+08:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:06:44" itemprop="dateModified" datetime="2022-10-15T10:06:44+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从进程管理到CPU调度，从内存管理再到文件管理，包含常见的操作系统相关问题，内容不断整理更新中</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/03/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">C++学习笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-17 09:41:00" itemprop="dateCreated datePublished" datetime="2021-03-17T09:41:00+08:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-10-15 10:06:22" itemprop="dateModified" datetime="2022-10-15T10:06:22+08:00">2022-10-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>整理了一些C++的相关问题，包含了C++的语言特性，以及部分底层原理，还有STL标准库的部分内容，内容不断整理更新中</p>
<!---more--->



<blockquote>
<p> C++三大特征：继承、多态、封装</p>
</blockquote>
<h3 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h3><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。<br>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态</p>
<h3 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h3><p>继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。<br>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p>
<h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。<br>比如函数重载、运算符重载、虚函数等</p>
<p>C++有两种多态形式：</p>
<ul>
<li>静态多态</li>
<li>动态多态</li>
</ul>
<h4 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h4><p><strong>静态多态</strong>：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。<br>静态多态有两种实现方式：</p>
<p><strong>函数重载</strong>：包括普通函数的重载和成员函数的重载<br><strong>函数模板的使用</strong></p>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>函数重载就像是有多种含义的动词。例如：你可以在棒球场为球队助威（root），也可以在地里种植（root）菌类植物。<br>根据上下文可以知道每种情况下，root的含义是什么，同样，C++中也通过上下文来确定同名函数的重载版本。<br>重载函数的关键是函数参数列表——也称函数特征标。包括：函数的参数数目和类型，以及参数的排列顺序。所以，重载函数与返回值，参数名无关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// print()函数</span><br><span class="line">void print(const char* str,int width);</span><br><span class="line">void print(double i ,int width);</span><br><span class="line">void print(const char* str);</span><br><span class="line">// 使用print()函数时，编译器将根据所采取的用法使用有相应特征标的原型</span><br><span class="line">print(&quot;abc&quot;,12);</span><br><span class="line">print(2.2,55);</span><br><span class="line">print(&quot;def&quot;);</span><br></pre></td></tr></table></figure>

<p>以下这种方式的重载是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void print(const char* str,int width);</span><br><span class="line">int print(const char* str,int width);</span><br></pre></td></tr></table></figure>

<p>重载时返回值可以不同，但特征标也必须不同。</p>
<h5 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h5><p>函数模板是通用的函数描述，也就是说，使用泛型来定义函数，其中泛型可用具体的类型（int 、double等）替换。通过将类型作为参数，传递给模板，可使编译器生成该类型的函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 交换两个值，但是不清楚是int 还是 double，如果不使用模板，则要写两份代码</span><br><span class="line">// 使用函数模板，将类型作为参数传递</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swa(T a,T b)</span><br><span class="line">&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h4><p>**动态多态（动态绑定)**：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p>
<h5 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h5><p>1.通过基类类型的引用或者指针调用虚函数<br>首先搞清楚这个对象的类型：</p>
<p>静态类型：对象声明时的类型，编译时确定<br>动态类型：目前所指对象的类型，运行时确定</p>
<p>2.必须是虚函数（派生类一定要重写基类中的虚函数）</p>
<h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“&#x3D;0” 。<br>包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。纯虚函数在派生类中重新定义以后，派生类才能实例化出对象。</p>
<ul>
<li>先拷贝基类的虚函数表</li>
<li>如果派生类重写了基类的某个虚函数，就用派生类的虚函数替换虚表同位置的基类虚函数</li>
<li>跟上派生类自己的虚函数</li>
</ul>
<p><strong>通过基类的引用或指针调用，调用基类还是派生类的虚函数，要根据运行时根据指针或引用实际指向或引用的类型确定，调用非虚函数时，则无论基类指向的是何种类型，都调用基类的函数</strong></p>
<h2 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h2><p>一个由C&#x2F;C++编译的程序占用的内存分为以下几个部分</p>
<table>
<thead>
<tr>
<th align="left">内存高位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">栈区</td>
</tr>
<tr>
<td align="left">堆区</td>
</tr>
<tr>
<td align="left">全局区</td>
</tr>
<tr>
<td align="left">文字常量区</td>
</tr>
<tr>
<td align="left">程序代码区</td>
</tr>
</tbody></table>
<ul>
<li>栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 &#x2F;&#x2F;栈从内存高位向内存低位拓展，由OS控制 堆从内存低位向内存高位拓展，是C&#x2F;C++的一个函数库。</li>
<li>堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li>全局区（静态区）（static）全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li>
<li>文字常量区 常量字符串就是放在这里的。程序结束后由系统释放</li>
<li>程序代码区 存放函数体的二进制代码。</li>
</ul>
<p>一个正常的程序在内存中通常分为程序段、数据端、堆栈三部分。程序段里放着程序的机器码、只读数据，这个段通常是只读，对它的写操作是非法的。数据段放的是程序中的静态数据。动态数据则通过堆栈来存放。</p>
<p>在函数体中定义的变量通常是在栈上，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。在所有函数体外定义的是全局量，加了static修饰符后不管在哪里都存放在全局区（静态区），在所有函数体外定义的static变量表示在该文件中有效，不能extern到别的文件用；在函数体内定义的static表示只在该函数体内有效。另外，函数中的”adgfdf”这样的字符串存放在常量区。</p>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h3 id="栈溢出概念："><a href="#栈溢出概念：" class="headerlink" title="栈溢出概念："></a>栈溢出概念：</h3><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变。</p>
<h3 id="栈溢出的原因："><a href="#栈溢出的原因：" class="headerlink" title="栈溢出的原因："></a>栈溢出的原因：</h3><ol>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此这个很好理解。解决这类问题的办法有两个，一是增大栈空间,二是改用动态分配，使用堆（heap）而不是栈（stack）。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol>
<li>指针有自己的一块空间，而引用只是一个别名；</li>
<li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>
<li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li>
<li>可以有const指针，空指针，但是没有const引用，空引用，引用必须被初始化且必须是一个已有对象的引用；</li>
<li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；</li>
<li>指针可以有多级指针（**p），而引用至于一级；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li>
</ol>
<h2 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h2><table>
<thead>
<tr>
<th align="left">指针</th>
<th align="left">数组</th>
</tr>
</thead>
<tbody><tr>
<td align="left">保存数据的地址</td>
<td align="left">保存数据</td>
</tr>
<tr>
<td align="left">间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据</td>
<td align="left">直接访问数据</td>
</tr>
<tr>
<td align="left">通常用于动态的数据结构</td>
<td align="left">通常用于固定数目且数据类型相同的元素</td>
</tr>
<tr>
<td align="left">通过Malloc分配内存，free释放内存</td>
<td align="left">隐式的分配和删除</td>
</tr>
<tr>
<td align="left">通常指向匿名数据，操作匿名函数</td>
<td align="left">自身即为数据名</td>
</tr>
</tbody></table>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
<h2 id="为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h2><p>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p>
<p>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。</p>
<h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p>创建一个和当前进程映像一样的进程可以通过fork( )系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pid_t fork(void);</span><br></pre></td></tr></table></figure>

<p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
<p>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</p>
<p>在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。</p>
<h2 id="C-中析构函数的作用"><a href="#C-中析构函数的作用" class="headerlink" title="C++中析构函数的作用"></a>C++中析构函数的作用</h2><p>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</p>
<p>析构函数名也应与类名相同，只是在函数名前面加一个位取反符<del>，例如</del>stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。</p>
<p>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</p>
<p>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</p>
<h2 id="静态函数和虚函数的区别"><a href="#静态函数和虚函数的区别" class="headerlink" title="静态函数和虚函数的区别"></a>静态函数和虚函数的区别</h2><p>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销</p>
<h2 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h2><p>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中<br>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</p>
<h2 id="虚函数和多态"><a href="#虚函数和多态" class="headerlink" title="虚函数和多态"></a>虚函数和多态</h2><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</p>
<p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</p>
<p>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p>
<h2 id="C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>C++里是怎么定义常量的？常量存放在内存的哪个位置？</h2><p>常量在C++里的定义就是一个top-level const加上对象类型，常量定义必须初始化。对于局部对象，常量存放在栈区，对于全局对象，常量存放在全局&#x2F;静态存储区。对于字面值常量，常量存放在常量存储区。</p>
<h2 id="const修饰成员函数的目的是什么？"><a href="#const修饰成员函数的目的是什么？" class="headerlink" title="const修饰成员函数的目的是什么？"></a>const修饰成员函数的目的是什么？</h2><p>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</p>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>首先，对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。</p>
<h2 id="new-x2F-delete与malloc-x2F-free的区别是什么"><a href="#new-x2F-delete与malloc-x2F-free的区别是什么" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的区别是什么"></a>new&#x2F;delete与malloc&#x2F;free的区别是什么</h2><p>首先，new&#x2F;delete是C++的关键字，而malloc&#x2F;free是C语言的库函数，后者使用必须指明申请内存空间的大小</p>
<p>对于类类型的对象，后者不会调用构造函数和析构函数</p>
<p>malloc需要给定申请内存的大小，返回的指针需要强转。<br>new会调用构造函数，不用指定内存大小，返回的指针不用强转。</p>
<h1 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a>容器和算法</h1><h2 id="map和set有什么区别，分别又是怎么实现的？"><a href="#map和set有什么区别，分别又是怎么实现的？" class="headerlink" title="map和set有什么区别，分别又是怎么实现的？"></a>map和set有什么区别，分别又是怎么实现的？</h2><p>map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。</p>
<p>unordered map底层结构是哈希表</p>
<p>map和set区别在于：</p>
<ol>
<li>map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。</li>
<li>set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。</li>
<li>map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。</li>
<li>set</li>
</ol>
<p>所有元素都会根据元素的值自动被排序，且不允许重复。</p>
<p>底层实现：红黑树</p>
<p>set 底层是通过红黑树（RB-tree）来实现的，由于红黑树是一种平衡二叉搜索树，自动排序的效果很不错，所以标准的 STL 的 set 即以 RB-Tree 为底层机制。又由于 set 所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 set 操作行为，都只有转调用 RB-tree 的操作行为而已。</p>
<p>适用场景：有序不重复集合</p>
<ol>
<li>map</li>
</ol>
<p>映射。map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。</p>
<p>底层：红黑树</p>
<p>适用场景：有序键值对不重复映射</p>
<h2 id="STL里resize和reserve的区别"><a href="#STL里resize和reserve的区别" class="headerlink" title="STL里resize和reserve的区别"></a>STL里resize和reserve的区别</h2><p>resize()：改变当前容器内含有元素的数量(size())，eg: vectorv; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；<br>reserve()：改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；</p>
<h2 id="STL中迭代器的作用，有指针为何还要迭代器"><a href="#STL中迭代器的作用，有指针为何还要迭代器" class="headerlink" title="STL中迭代器的作用，有指针为何还要迭代器"></a>STL中迭代器的作用，有指针为何还要迭代器</h2><ol>
<li>迭代器</li>
</ol>
<p>Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</p>
<p>由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</p>
<ol>
<li>迭代器和指针的区别</li>
</ol>
<p>迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、*、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</p>
<p>迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。</p>
<ol>
<li>迭代器产生原因</li>
</ol>
<p>Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
<h1 id="类和数据抽象"><a href="#类和数据抽象" class="headerlink" title="类和数据抽象"></a>类和数据抽象</h1><h2 id="C-中类成员的访问权限"><a href="#C-中类成员的访问权限" class="headerlink" title="C++中类成员的访问权限"></a>C++中类成员的访问权限</h2><p>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员</p>
<h2 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h2><p>在C++中，可以用struct和class定义类，都可以继承。区别在于：structural的默认继承权限和默认访问权限是public，而class的默认继承权限和默认访问权限是private。</p>
<p>另外，class还可以定义模板类形参，比如template &lt;class T, int i&gt;。</p>
<h2 id="C-类内可以定义引用数据成员吗"><a href="#C-类内可以定义引用数据成员吗" class="headerlink" title="C++类内可以定义引用数据成员吗"></a>C++类内可以定义引用数据成员吗</h2><p>可以，必须通过成员函数初始化列表初始化。</p>
<h2 id="什么是右值引用，跟左值又有什么区别"><a href="#什么是右值引用，跟左值又有什么区别" class="headerlink" title="什么是右值引用，跟左值又有什么区别"></a>什么是右值引用，跟左值又有什么区别</h2><p>右值引用是C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：</p>
<ol>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ol>
<p>左值和右值的概念：</p>
<p>左值：能对表达式取地址、或具名对象&#x2F;变量。一般指表达式结束后依然存在的持久对象。</p>
<p>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</p>
<p>右值引用和左值引用的区别：</p>
<ol>
<li>左值可以寻址，而右值不可以。</li>
<li>左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。</li>
<li>左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</li>
</ol>
<h1 id="编译和底层"><a href="#编译和底层" class="headerlink" title="编译和底层"></a>编译和底层</h1><h2 id="一个C-源文件从文本到可执行文件经历的过程？"><a href="#一个C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="一个C++源文件从文本到可执行文件经历的过程？"></a>一个C++源文件从文本到可执行文件经历的过程？</h2><p>对于C++源文件，从文本到可执行文件一般需要四个过程：<br>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</p>
<p>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</p>
<p>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</p>
<p>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
<h2 id="include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h2><p>Include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。<br>双引号和尖括号的区别：编译器预处理阶段查找头文件的路径不一样。</p>
<p>对于使用双引号包含的头文件，查找头文件路径的顺序为：</p>
<p>当前头文件目录</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH指定的头文件路径</p>
<p>对于使用尖括号包含的头文件，查找头文件的路径顺序为：</p>
<p>编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）</p>
<p>系统变量CPLUS_INCLUDE_PATH&#x2F;C_INCLUDE_PATH指定的头文件路径</p>
<h2 id="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"><a href="#malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？" class="headerlink" title="malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？"></a>malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么？</h2><p>Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。<br>当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。</p>
<p>Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。</p>
<h2 id="C-的内存管理是怎样的？"><a href="#C-的内存管理是怎样的？" class="headerlink" title="C++的内存管理是怎样的？"></a>C++的内存管理是怎样的？</h2><p>在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。<br>代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。</p>
<p>数据段：存储程序中已初始化的全局变量和静态变量</p>
<p>bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。</p>
<p>堆区：调用new&#x2F;malloc函数时在堆区动态分配内存，同时需要调用delete&#x2F;free来手动释放申请的内存。</p>
<p>映射区:存储动态链接库以及调用mmap函数进行的文件映射</p>
<p>栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
<h2 id="什么时候会发生段错误？"><a href="#什么时候会发生段错误？" class="headerlink" title="什么时候会发生段错误？"></a>什么时候会发生段错误？</h2><p>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：</p>
<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
<h2 id="什么是memory-leak，也就是内存泄漏"><a href="#什么是memory-leak，也就是内存泄漏" class="headerlink" title="什么是memory leak，也就是内存泄漏"></a>什么是memory leak，也就是内存泄漏</h2><p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。<br>内存泄漏的分类：</p>
<ol>
<li>堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.</li>
<li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。</li>
</ol>
<h2 id="如何判断内存泄漏？"><a href="#如何判断内存泄漏？" class="headerlink" title="如何判断内存泄漏？"></a>如何判断内存泄漏？</h2><p>内存泄漏通常是由于调用了malloc&#x2F;new等内存申请的操作，但是缺少了对应的free&#x2F;delete。为了判断内存是否泄露，我们一方面可以使用linux环境下的内存泄漏检查工具Valgrind,另一方面我们在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否泄露。</p>
<h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><ol>
<li>new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</li>
<li>new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。</li>
<li>new不仅分配一段内存，而且会调用构造函数，malloc不会。</li>
<li>new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。</li>
<li>new是一个操作符可以重载，malloc是一个库函数。</li>
<li>malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。</li>
<li>new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</li>
<li>申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</li>
</ol>
<h2 id="共享内存相关api"><a href="#共享内存相关api" class="headerlink" title="共享内存相关api"></a>共享内存相关api</h2><p>Linux允许不同进程访问同一个逻辑内存，提供了一组API，头文件在sys&#x2F;shm.h中。<br>1）新建共享内存shmget</p>
<p>int shmget(key_t key,size_t size,int shmflg);</p>
<p>key：共享内存键值，可以理解为共享内存的唯一性标记。</p>
<p>size：共享内存大小</p>
<p>shmflag：创建进程和其他进程的读写权限标识。</p>
<p>返回值：相应的共享内存标识符，失败返回-1</p>
<p>2）连接共享内存到当前进程的地址空间shmat</p>
<p>void *shmat(int shm_id,const void *shm_addr,int shmflg);</p>
<p>shm_id：共享内存标识符</p>
<p>shm_addr：指定共享内存连接到当前进程的地址，通常为0，表示由系统来选择。</p>
<p>shmflg：标志位</p>
<p>返回值：指向共享内存第一个字节的指针，失败返回-1</p>
<p>3）当前进程分离共享内存shmdt</p>
<p>int shmdt(const void *shmaddr);</p>
<p>4）控制共享内存shmctl</p>
<p>和信号量的semctl函数类似，控制共享内存</p>
<p>int shmctl(int shm_id,int command,struct shmid_ds *buf);</p>
<p>shm_id：共享内存标识符</p>
<p>command: 有三个值</p>
<p>IPC_STAT:获取共享内存的状态，把共享内存的shmid_ds结构复制到buf中。</p>
<p>IPC_SET:设置共享内存的状态，把buf复制到共享内存的shmid_ds结构。</p>
<p>IPC_RMID:删除共享内存</p>
<p>buf：共享内存管理结构体。</p>
<h2 id="自己设计一下如何采用单线程的方式处理高并发"><a href="#自己设计一下如何采用单线程的方式处理高并发" class="headerlink" title="自己设计一下如何采用单线程的方式处理高并发"></a>自己设计一下如何采用单线程的方式处理高并发</h2><p>在单线程模型中，可以采用I&#x2F;O复用来提高单线程处理多个请求的能力，然后再采用事件驱动模型，基于异步回调来处理事件来</p>
<h2 id="C-STL-的内存优化"><a href="#C-STL-的内存优化" class="headerlink" title="C++ STL 的内存优化"></a>C++ STL 的内存优化</h2><p>1）二级配置器结构<br>STL内存管理使用二级内存配置器。<br>1、第一级配置器<br>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。<br>一级空间配置器分配的是大于128字节的空间<br>如果分配不成功，调用句柄释放一部分内存<br>如果还不能分配成功，抛出异常<br>2、第二级配置器<br>在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。<br>3、分配原则<br>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。<br>当用户申请的空间小于128字节时，将字节数扩展到8的倍数，然后在自由链表中查找对应大小的子链表<br>如果在自由链表查找不到或者块数不够，则向内存池进行申请，一般一次申请20块<br>如果内存池空间足够，则取出内存<br>如果不够分配20块，则分配最多的块数给自由链表，并且更新每次申请的块数<br>如果一块都无法提供，则把剩余的内存挂到自由链表，然后向系统heap申请空间，如果申请失败，则看看自由链表还有没有可用的块，如果也没有，则最后调用一级空间配置器<br>2）二级内存池<br>二级内存池采用了16个空闲链表，这里的16个空闲链表分别管理大小为8、16、24……120、128的数据块。这里空闲链表节点的设计十分巧妙，这里用了一个联合体既可以表示下一个空闲数据块（存在于空闲链表中）的地址，也可以表示已经被用户使用的数据块（不存在空闲链表中）的地址。<br><img src="https://s3.ax1x.com/2021/01/18/scVfOO.md.png" alt="img"><br>1、空间配置函数allocate<br>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用数据块，则直接拿来用（拿取空闲链表中的第一个可用数据块，然后把该空闲链表的地址设置为该数据块指向的下一个地址），如果没有可用数据块，则调用refill重新填充空间。<br>2、空间释放函数deallocate<br>首先先要检查释放数据块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据数据块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>3、重新填充空闲链表refill<br>在用allocate配置空间时，如果空闲链表中没有可用数据块，就会调用refill来重新填充空间，新的空间取自内存池。缺省取20个数据块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>从内存池取空间给空闲链表用是chunk_alloc的工作，首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的数据块出去，如果内存连一个数据块的空间都无法供应，需要用malloc取堆中申请内存。<br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的数据块，然后将该数据块的空间分给内存池（这个数据块会从链表中去除）。<br>3、总结：</p>
<ol>
<li>使用allocate向内存池请求size大小的内存空间，如果需要请求的内存大小大于128bytes，直接使用malloc。</li>
<li>如果需要的内存大小小于128bytes，allocate根据size找到最适合的自由链表。<br>a. 如果链表不为空，返回第一个node，链表头改为第二个node。<br>b. 如果链表为空，使用blockAlloc请求分配node。<br>x. 如果内存池中有大于一个node的空间，分配竟可能多的node(但是最多20个)，将一个node返回，其他的node添加到链表中。<br>y. 如果内存池只有一个node的空间，直接返回给用户。<br>z. 若果如果连一个node都没有，再次向操作系统请求分配内存。<br>①分配成功，再次进行b过程。<br>②分配失败，循环各个自由链表，寻找空间。<br>I. 找到空间，再次进行过程b。<br>II. 找不到空间，抛出异常。</li>
<li>用户调用deallocate释放内存空间，如果要求释放的内存空间大于128bytes，直接调用free。</li>
<li>否则按照其大小找到合适的自由链表，并将其插入。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/13/Deep-Meta-Learning-for-Real-Time-Target-Aware-Visual-Tracking-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Wang shushu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gbwss">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/13/Deep-Meta-Learning-for-Real-Time-Target-Aware-Visual-Tracking-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-title-link" itemprop="url">Deep Meta Learning for Real-Time Target-Aware Visual Tracking 论文阅读</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-13 19:07:04" itemprop="dateCreated datePublished" datetime="2020-05-13T19:07:04+08:00">2020-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-15 11:53:52" itemprop="dateModified" datetime="2020-05-15T11:53:52+08:00">2020-05-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章是韩国的一个组做的,一直没中, 直到19年中了ICCV，据说是第一篇将元学习引入目标跟踪的文章，用的架构是siamese网络的架构，但是在模型在线更新的时候使用了meta-learning的思想。</p>
<!---more--->

<hr>
<h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>the number of positive samples are highly limited.</li>
<li>overfitting</li>
</ul>
<p>在跟踪过程中,当目标外观发生变化时，需要对模型进行更新。而更新操作需要采用stochastic gradient descent (SGD)随机梯度下降，Lagrange multipliers , ridge regressio等方法，效率很低，通常低于20FPS，无法满足实时性需求。此外，更新通常是利用跟踪过程中等少量目标外观模型（a handful of target appearance templates obtained in the course of tracking）来进行的，由于正样本不足，所以模型很容易陷入过拟合（overfitting）而失去泛化能力。</p>
<hr>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>本文基于以上背景和动机，提出了一种 end to end visual tracking network structure，主要包括了两个部分</p>
<ul>
<li>Siamese matching network for target search</li>
<li>meta-learning network for adaptive feature space.</li>
</ul>
<p>在跟踪算法SiameseFc基础上，这里简称matching network，添加了meta-learner network，在运行时动态产生部分matching network的参数。利用meta-learner network，能够使matching network适应目标外形变化，而且对matching network动态新增的参数，也只需要计算forward-pass就可以，因此，实时效果好，达到了48fps，整体流程如下图如所示：<br><img src="https://s1.ax1x.com/2020/05/13/Yd75xP.png" alt="Yd75xP.png"><br>训练后的元学习网络为matching network（本文中就是SiameseFC网络）提供了额外的卷积核和channel attention information，从而让特征空间（feature space）可以根据追踪过程中获得的新的外观模版（new appearance templates obtained in the course of tracking）进行自适应修改，而不会产生过拟合情况。</p>
<hr>
<h2 id="Meta-learning"><a href="#Meta-learning" class="headerlink" title="Meta-learning"></a>Meta-learning</h2><p>简单来说就是像人一样在学习了很多个task之后，但面对新的task时能够借助以往的学习知识以及少量的新样本快速地适应到新的任务上，就像我们玩lol玩的很好，那么上手王者荣耀是一个道理。<br>其实meta-learning这个概念很早就提出，只是目前将其应用于深度学习和强化学习领域做出了一些效果，或提高性能，或提高训练效率。目前对meta-learning的理解，可以简单理解为learning to learn，换句话解释就是要去学习超参，那对超参的定义可以理解为设计算法时不是由data-driven的部分，可以是模型结构，可以是训练参数，也可以是根据情况动态修改模型结构等。总之，meta-learning就是要学习并替代设计算法时人的工作。<br>本文中的meta-learning其实应用主要是应用了meta-learning的思想，使用meta-learning来更新最后一层卷积层（conv5）的weight。使之产生一个可以根据现有追踪模版自适应更新的权值，然后把原始的权重和meta-learning网络生成的权值合并，生成最后的W adapt。</p>
<blockquote>
<p>这里分享一下我看的李宏毅老师的机器学习讲meta-learning相关的一些小知识，就是在meta-learning网络训练的时候，并不追求单一任务上的最优，而是去寻找可以让所有task都能下降到分别的全局最优。就像下面这两张图。<br><img src="https://s1.ax1x.com/2020/05/13/YdxhGD.jpg" alt="YdxhGD.jpg"><br><img src="https://s1.ax1x.com/2020/05/13/YdxfPO.jpg" alt="YdxfPO.jpg"></p>
</blockquote>
<hr>
<h2 id="SiameseFc"><a href="#SiameseFc" class="headerlink" title="SiameseFc"></a>SiameseFc</h2><p>SiameseFc跟踪算法，没有采用更新model或者维护template，而是使用两个全卷积cnn组成Simaese network，提取卷积层特征做相关，产生heatmap来预测目标位置，如下图所示。两个网络中，一个输入是起始帧的目标模板，另一个输入是目标附近更大范围的区域（一般可以设为4倍，相当于搜索区域）。<br><img src="https://s1.ax1x.com/2020/05/13/Ydx6q1.png" alt="Ydx6q1.png"><br>上图中可以看出其核心计算公式：</p>
<p><img src="https://s1.ax1x.com/2020/05/13/Ydz9Ln.png" alt="Ydz9Ln.png"><br>网络的损失函数如下式所示，y[u]表示真实标签，其定位目标框内为1，框外为-1：<br><img src="https://s1.ax1x.com/2020/05/13/YdxRIK.jpg" alt="YdxRIK.jpg"></p>
<p>好了 让我们开始正文吧！</p>
<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>文章的网络结构如下：<br><img src="https://s1.ax1x.com/2020/05/13/YwMVfg.png" alt="YwMVfg.png"><br>蓝色的就是SiamFC的结构, 文章是提特征, 然后用conv5的特征算一个loss, 然后把梯度给Meta-learner这个网络, 去算一个权重出来, 还算了一个attention, 再把权重concate到原始conv5的weight上面, 然后用这个新的weight来计算最终的features, 在这两个feature上做互相关.</p>
<hr>
<h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>首先我们来看蓝色的部分，实际上就是一个SiameseFc网络，使用具有5个卷积层的CNN，并在前两个卷积层之后应用2个内核大小为3和步幅为2的池化层。在每个卷积层之后插入批处理归一化层（Batch normalization layer）。<br>CNN的每层的内核大小和输入&#x2F;输出尺寸为w1：11×11×3×128，w2：5×5×128×256，w3：3×3 ×256×384，w4：3×3×384×256，w5：1×1×256×192。对于输入，为x使用大小为127×127×3的RGB图像，为z使用大小为255×255×3的RGB图像，匹配网络生成大小为17×17的响应图。<br>实际上就是先做卷积，然后再求互相关：<br><img src="https://s1.ax1x.com/2020/05/13/YwQ3DI.png" alt="YwQ3DI.png"><br>式中 x为模版，z为搜索区域，w &#x3D; {w1,w2, …,wN}表示每一层的一组权重，ϕw(⋅)表示整个网络权重为 w 时的使用Nlayer 特征提取器提取出的特征。</p>
<p>meta-learner network根据matching network在之前追踪过程中产生的M个context patches z &#x3D; {z1, …, zM}以及target x，来计算能够使追踪模版自适应更新的新增参数。</p>
<p>首先使用matching network最后一层conv5来计算平均负梯度：<br><img src="https://s1.ax1x.com/2020/05/13/YwQ1KA.png" alt="YwQ1KA.png"><br>其中 yi表示根据ground-truth来计算出针对zi的二值标签图，也就是响应图（response map。meta-leaner设计的依据是目标发生变化，那么δ也发生变化（the characteristic of δ is empirically different according to a target）</p>
<p>然后，以δ作为输入，meta-learner 网络 g（·）可以生成与输入对应的目标特定权重（target-specific weights），如下：<br><img src="https://s1.ax1x.com/2020/05/13/YwQuCD.png" alt="YwQuCD.png"><br>￼然后将两个权重拼接起来就来更新matching network原始的权重</p>
<blockquote>
<p>这里插一嘴，上面所说的拼接是真的拼接，就是简单相加，这一点可以在后文中介绍meta-learner网络中得到印证<br>[w5,wtarget] of size 1×1×256×(192+32).</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/13/YwQQvd.png" alt="YwQQvd.png"></p>
<blockquote>
<p>论文还说这里同时生成了一个channel-wise sig- moid attention weights这样的权重，文中也没有讲具体实现，同时我在后文中也没有看到如何使用</p>
</blockquote>
<hr>
<h2 id="Tracking-algorithm"><a href="#Tracking-algorithm" class="headerlink" title="Tracking algorithm"></a>Tracking algorithm</h2><p>对于跟踪过程，首先保存K个context images as zmem &#x3D; {z1 , …, zK }，以及对应的响应图 yˆ &#x3D; {yˆ ,…,yˆK}.保存的原则是, 当在每一帧找出target之后, 会判断当前这个target的响应是否大于一个阈值 τ , 若是大于 τ , 便把这个patch加入到template的池中：<br><img src="https://s1.ax1x.com/2020/05/13/YwQMgH.png" alt="YwQMgH.png"><br>式子中的p对应于响应图中所有可能位置P的集合中的位置，而ρ（·）是归一化函数。<br>而在接下来计算要输入meta-learner网络的δ时，从template池中选择熵最小的,其实就是找响应比较大, 比较靠谱那M个template用来更新网络。</p>
<blockquote>
<p>文章中提到，这里提出了一个新的响应图yˆ ⊗ h，加入了一个余弦窗函数，这个h就是余弦窗函数，用来惩罚大位移，保证目标大小平滑变化。</p>
</blockquote>
<p>整个跟踪流程如下：<br><img src="https://s1.ax1x.com/2020/05/13/YwYL79.png" alt="YwYL79.png"></p>
<hr>
<h1 id="Implementation-and-Training"><a href="#Implementation-and-Training" class="headerlink" title="Implementation and Training"></a>Implementation and Training</h1><p><img src="https://s1.ax1x.com/2020/05/13/YwQYUf.png" alt="YwQYUf.png"><br>meta-learner网络使用（2）中的损失梯度δ作为输入，该信息是从matching network中获得的，它解释了其在当前特征空间中的状态。然后，meta-learner 网络中的g(·)学习从该损失梯度到自适应权重Wtarget的映射，该权重描述目标特定的特征空间，也就是所谓的目标特定权重（target-specific weights）。可以通过损失函数来训练元学习器网络，该函数可以衡量自适应权重Wtarget在正确拟合新示例{z1，…，zM’}时的准确度。</p>
<h2 id="Matching-Network"><a href="#Matching-Network" class="headerlink" title="Matching Network"></a>Matching Network</h2><h3 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h3><p>5 convolutional layers<br>2 pooling layers of kernel size 3 and stride 2 are applied after the first two convolutional layers.<br>w1 : 11×11×3×128,<br>w2 : 5×5×128×256,<br>w3 : 3×3×256×384,<br>w4 : 3×3×384×256,<br>w5 : 1×1×256×192.<br>Inputs,<br>27×127×3  for x<br>255×255×3 for z<br>response map<br>17 × 17  </p>
<h3 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h3><p>在训练时，对(x,z)从选定的视频序列中的目标轨迹中随机采样。然后，生成ground-truth响应映射y∈{−1，+1}17×17，其中值在目标位置为+1，否则为- 1。对于损失函数l(fw(x, z)， y)，文章使用logistic损失函数定义为：<br><img src="https://s1.ax1x.com/2020/05/13/YwQJVP.png" alt="YwQJVP.png"><br>式中，p表示响应图中每个可能位置P的集合中的一个位置，而ζ（y [p]）是减轻标签不平衡的加权函数。<br>损失函数使用Adam优化器进行了优化，使用批处理大小为8的学习率为10−4，并运行95000次迭代。</p>
<h2 id="Meta-learner-Network"><a href="#Meta-learner-Network" class="headerlink" title="Meta-learner Network"></a>Meta-learner Network</h2><h3 id="Network-1"><a href="#Network-1" class="headerlink" title="Network"></a>Network</h3><p>3 fully-connected layers<br>Each intermediate layer is followed by a dropout layer with the keep probability of 0.7 when training.<br>For input, gradient δ of size<br>1×1×256×192<br>output Wtarget of size<br>1×1×256×32<br>合并之后的权重 [w5,wtarget]<br>1×1×256×(192+32)</p>
<h3 id="Train-1"><a href="#Train-1" class="headerlink" title="Train"></a>Train</h3><p>训练的时候从一个训练序列中随机抽取M′个(M′≥M)context patch，也就是Zreg &#x3D;{z1,…,zM′}然后从中取M个来计算梯度δ。接着利用公式2，来计算响应二值图。注意，这里的计算二值图，是在假定目标位于中心来进行计算的(assuming the target is located at the center i<br>of zi)。这样做的目的就是在于我前面提到的，训练meta-learner network并不追求单一任务上的最优，而是去寻找可以让所有task都能下降到分别的全局最优，所以这里假设目标在context patch的中心，这样不管目标去哪里，我们的x都能很快的响应。<br>meta-learner network的损失函数，针对meta-learne network进行最优化，matching network固定不变，如下式所示，<br><img src="https://s1.ax1x.com/2020/05/13/YwQ8bt.png" alt="YwQ8bt.png"></p>
<hr>
<h1 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h1><p><img src="https://s1.ax1x.com/2020/05/14/Y0t0dH.png" alt="Y0t0dH.png"><br>OTB[51]和LaSOT[12]数据集的定量结果。MLT为提出的算法。该算法在OTB数据集上表现出了较好的性能，在大规模LaSOT数据集上表现优于其他算法，并利用元学习器提供的额外特征空间获得了性能提升。</p>
<p><img src="https://s1.ax1x.com/2020/05/14/Y0tBod.png" alt="Y0tBod.png"><br>MLT-mt    只加入了meta-learner<br>MLT-mt-ft 加入了Adam优化器进行finetuning</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Wang shushu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang shushu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
















  

  

</body>
</html>
